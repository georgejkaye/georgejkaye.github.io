// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as $$Array from "../../../node_modules/bs-platform/lib/es6/array.js";
import * as Curry from "../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Caml_obj from "../../../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Caml_array from "../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Pervasives from "../../../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Caml_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_exceptions.js";
import * as Caml_builtin_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as Helpers$CircuitVisualiser from "./Helpers.bs.js";
import * as Circuits$CircuitVisualiser from "./Circuits.bs.js";

var alpha = "α";

var omega = "ω";

var alphaLatex = "\\alpha";

var omegaLatex = "\\omega";

var stubLatex = "\\sim";

var forkLatex = "\\curlywedge";

var dforkLatex = "\\Delta";

var GraphError = Caml_exceptions.create("Hypernets-CircuitVisualiser.GraphError");

function graphError(message) {
  throw [
        GraphError,
        message
      ];
}

function findEdges$prime(string, _edges, _acc) {
  while(true) {
    var acc = _acc;
    var edges = _edges;
    if (edges) {
      var xs = edges[1];
      var x = edges[0];
      var match = x.contents.label === string;
      if (match) {
        _acc = /* :: */[
          x,
          acc
        ];
        _edges = xs;
        continue ;
      } else {
        _edges = xs;
        continue ;
      }
    } else {
      return acc;
    }
  };
}

function findEdges(string, net) {
  return findEdges$prime(string, net.edges, /* [] */0);
}

function printEdgeRefPortPairArray(es) {
  return Helpers$CircuitVisualiser.printArray(es, (function (param) {
                return param[0].contents.label + (":" + String(param[1]));
              }));
}

function printEdge(e) {
  return "edge " + (String(e.id) + (": " + (e.label + (", sources: " + (printEdgeRefPortPairArray(e.sources) + (", targets: " + printEdgeRefPortPairArray(e.targets)))))));
}

function printEdgeArray(es) {
  return Helpers$CircuitVisualiser.printArray(es, printEdge);
}

function printEdgeRefArray(es) {
  return Helpers$CircuitVisualiser.printArray(es, (function (x) {
                return printEdge(x.contents);
              }));
}

function printEdgeRefList(es) {
  return Helpers$CircuitVisualiser.printList(es, (function (x) {
                return printEdge(x.contents);
              }));
}

function printHypernet(h) {
  return "hypernet inputs " + (printEdge(h.inputs.contents) + (", outputs " + (printEdge(h.outputs.contents) + (", edges " + printEdgeRefList(h.edges)))));
}

function floatingEdge(id, label, latex) {
  return {
          contents: {
            id: id,
            sources: /* array */[],
            targets: /* array */[],
            label: label,
            latex: latex
          }
        };
}

function initialisePorts(x) {
  return $$Array.init(x, (function (i) {
                return /* tuple */[
                        {
                          contents: {
                            id: 0,
                            sources: /* array */[],
                            targets: /* array */[],
                            label: "",
                            latex: ""
                          }
                        },
                        i
                      ];
              }));
}

var zeroNet_inputs = floatingEdge(0, alpha, alphaLatex);

var zeroNet_outputs = floatingEdge(1, omega, omegaLatex);

var zeroNet = {
  inputs: zeroNet_inputs,
  edges: /* [] */0,
  outputs: zeroNet_outputs
};

function identity(array) {
  return array;
}

function removeEdge$prime(edge, _edges, _acc) {
  while(true) {
    var acc = _acc;
    var edges = _edges;
    if (edges) {
      var xs = edges[1];
      var x = edges[0];
      var match = x.contents.id === edge.contents.id;
      if (match) {
        return Pervasives.$at(acc, xs);
      } else {
        _acc = /* :: */[
          x,
          acc
        ];
        _edges = xs;
        continue ;
      }
    } else {
      return acc;
    }
  };
}

function removeEdge(param, edge) {
  return {
          inputs: param.inputs,
          edges: removeEdge$prime(edge, param.edges, /* [] */0),
          outputs: param.outputs
        };
}

function composeSequential(f, g) {
  if (f.outputs.contents.sources.length !== g.inputs.contents.targets.length) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Hypernets.re",
            71,
            4
          ]
        ];
  }
  for(var i = 0 ,i_finish = f.outputs.contents.sources.length - 1 | 0; i <= i_finish; ++i){
    var match = Caml_array.caml_array_get(f.outputs.contents.sources, i);
    var k = match[1];
    var e = match[0];
    var match$1 = Caml_array.caml_array_get(g.inputs.contents.targets, i);
    var k$prime = match$1[1];
    var e$prime = match$1[0];
    Caml_array.caml_array_set(e.contents.targets, k, /* tuple */[
          e$prime,
          k$prime
        ]);
    Caml_array.caml_array_set(e$prime.contents.sources, k$prime, /* tuple */[
          e,
          k
        ]);
  }
  return {
          inputs: f.inputs,
          edges: Pervasives.$at(f.edges, g.edges),
          outputs: g.outputs
        };
}

function composeParallel(f, g, i) {
  var newInputs_sources = /* array */[];
  var newInputs_targets = $$Array.append(f.inputs.contents.targets, g.inputs.contents.targets);
  var newInputs = {
    id: 0,
    sources: newInputs_sources,
    targets: newInputs_targets,
    label: alpha,
    latex: alphaLatex
  };
  var newOutputs_id = i + 1 | 0;
  var newOutputs_sources = $$Array.append(f.outputs.contents.sources, g.outputs.contents.sources);
  var newOutputs_targets = /* array */[];
  var newOutputs = {
    id: newOutputs_id,
    sources: newOutputs_sources,
    targets: newOutputs_targets,
    label: omega,
    latex: omegaLatex
  };
  var finputs = f.inputs.contents.targets.length;
  var foutputs = f.outputs.contents.sources.length;
  var refInputs = {
    contents: newInputs
  };
  var refOutputs = {
    contents: newOutputs
  };
  for(var i$1 = 0 ,i_finish = f.inputs.contents.targets.length - 1 | 0; i$1 <= i_finish; ++i$1){
    var match = Caml_array.caml_array_get(f.inputs.contents.targets, i$1);
    var k = match[1];
    var e = match[0];
    var match$1 = e.contents.label === omega;
    if (match$1) {
      Caml_array.caml_array_set(refOutputs.contents.sources, k, /* tuple */[
            refInputs,
            i$1
          ]);
    } else {
      Caml_array.caml_array_set(e.contents.sources, k, /* tuple */[
            refInputs,
            i$1
          ]);
    }
  }
  for(var i$2 = 0 ,i_finish$1 = g.inputs.contents.targets.length - 1 | 0; i$2 <= i_finish$1; ++i$2){
    var match$2 = Caml_array.caml_array_get(g.inputs.contents.targets, i$2);
    var k$1 = match$2[1];
    var e$1 = match$2[0];
    var match$3 = e$1.contents.label === omega;
    if (match$3) {
      Caml_array.caml_array_set(refOutputs.contents.sources, k$1 + foutputs | 0, /* tuple */[
            refInputs,
            i$2 + finputs | 0
          ]);
    } else {
      Caml_array.caml_array_set(e$1.contents.sources, k$1, /* tuple */[
            refInputs,
            i$2 + finputs | 0
          ]);
    }
  }
  for(var i$3 = 0 ,i_finish$2 = f.outputs.contents.sources.length - 1 | 0; i$3 <= i_finish$2; ++i$3){
    var match$4 = Caml_array.caml_array_get(f.outputs.contents.sources, i$3);
    var k$2 = match$4[1];
    var e$2 = match$4[0];
    var match$5 = e$2.contents.label === alpha;
    if (match$5) {
      Caml_array.caml_array_set(refInputs.contents.targets, k$2, /* tuple */[
            refOutputs,
            i$3
          ]);
    } else {
      Caml_array.caml_array_set(e$2.contents.targets, k$2, /* tuple */[
            refOutputs,
            i$3
          ]);
    }
  }
  for(var i$4 = 0 ,i_finish$3 = g.outputs.contents.sources.length - 1 | 0; i$4 <= i_finish$3; ++i$4){
    var match$6 = Caml_array.caml_array_get(g.outputs.contents.sources, i$4);
    var k$3 = match$6[1];
    var e$3 = match$6[0];
    var match$7 = e$3.contents.label === alpha;
    if (match$7) {
      Caml_array.caml_array_set(refInputs.contents.targets, k$3 + finputs | 0, /* tuple */[
            refOutputs,
            i$4 + foutputs | 0
          ]);
    } else {
      Caml_array.caml_array_set(e$3.contents.targets, k$3, /* tuple */[
            refOutputs,
            i$4 + foutputs | 0
          ]);
    }
  }
  return {
          inputs: refInputs,
          edges: Pervasives.$at(f.edges, g.edges),
          outputs: refOutputs
        };
}

function functionNet(label, latex, ins, outs, i) {
  var ine = floatingEdge(i, "", "");
  var oute = floatingEdge(i + 2 | 0, "", "");
  var fune = {
    contents: {
      id: i + 1 | 0,
      sources: $$Array.init(ins, (function (n) {
              return /* tuple */[
                      ine,
                      n
                    ];
            })),
      targets: $$Array.init(outs, (function (n) {
              return /* tuple */[
                      oute,
                      n
                    ];
            })),
      label: label,
      latex: latex
    }
  };
  ine.contents = {
    id: 0,
    sources: /* array */[],
    targets: $$Array.init(ins, (function (n) {
            return /* tuple */[
                    fune,
                    n
                  ];
          })),
    label: alpha,
    latex: alphaLatex
  };
  oute.contents = {
    id: i + 2 | 0,
    sources: $$Array.init(outs, (function (n) {
            return /* tuple */[
                    fune,
                    n
                  ];
          })),
    targets: /* array */[],
    label: omega,
    latex: omegaLatex
  };
  return /* tuple */[
          {
            inputs: ine,
            edges: /* :: */[
              fune,
              /* [] */0
            ],
            outputs: oute
          },
          i + 3 | 0
        ];
}

function traceHypernet(x, h) {
  for(var i = 0 ,i_finish = x - 1 | 0; i <= i_finish; ++i){
    var match = Caml_array.caml_array_get(h.inputs.contents.targets, i);
    var k = match[1];
    var e = match[0];
    var match$1 = Caml_array.caml_array_get(h.outputs.contents.sources, i);
    var k$prime = match$1[1];
    var e$prime = match$1[0];
    Caml_array.caml_array_set(e$prime.contents.targets, k$prime, /* tuple */[
          e,
          k
        ]);
    Caml_array.caml_array_set(e.contents.sources, k, /* tuple */[
          e$prime,
          k$prime
        ]);
  }
  var newInputs_sources = /* array */[];
  var newInputs_targets = $$Array.sub(h.inputs.contents.targets, x, h.inputs.contents.targets.length - x | 0);
  var newInputs = {
    id: 0,
    sources: newInputs_sources,
    targets: newInputs_targets,
    label: alpha,
    latex: alphaLatex
  };
  var newOutputs_id = h.outputs.contents.id;
  var newOutputs_sources = $$Array.sub(h.outputs.contents.sources, x, h.outputs.contents.sources.length - x | 0);
  var newOutputs_targets = /* array */[];
  var newOutputs = {
    id: newOutputs_id,
    sources: newOutputs_sources,
    targets: newOutputs_targets,
    label: omega,
    latex: omegaLatex
  };
  for(var i$1 = 0 ,i_finish$1 = newInputs_targets.length - 1 | 0; i$1 <= i_finish$1; ++i$1){
    var match$2 = Caml_array.caml_array_get(newInputs_targets, i$1);
    var k$1 = match$2[1];
    var e$1 = match$2[0];
    var match$3 = e$1.contents.label === omega;
    var k$2 = match$3 ? k$1 - x | 0 : k$1;
    Caml_array.caml_array_set(newInputs_targets, i$1, /* tuple */[
          e$1,
          k$2
        ]);
  }
  for(var i$2 = 0 ,i_finish$2 = newOutputs_targets.length - 1 | 0; i$2 <= i_finish$2; ++i$2){
    var match$4 = Caml_array.caml_array_get(newInputs_sources, i$2);
    var k$3 = match$4[1];
    var e$2 = match$4[0];
    var match$5 = e$2.contents.label === alpha;
    var k$4 = match$5 ? k$3 - x | 0 : k$3;
    Caml_array.caml_array_set(newInputs_sources, i$2, /* tuple */[
          e$2,
          k$4
        ]);
  }
  for(var i$3 = 0 ,i_finish$3 = newInputs_targets.length - 1 | 0; i$3 <= i_finish$3; ++i$3){
    var match$6 = Caml_array.caml_array_get(newInputs_targets, i$3);
    var k$5 = match$6[1];
    var e$3 = match$6[0];
    var match$7 = Caml_array.caml_array_get(e$3.contents.sources, k$5);
    Caml_array.caml_array_set(e$3.contents.sources, k$5, /* tuple */[
          match$7[0],
          match$7[1] - x | 0
        ]);
  }
  for(var i$4 = 0 ,i_finish$4 = newOutputs_sources.length - 1 | 0; i$4 <= i_finish$4; ++i$4){
    var match$8 = Caml_array.caml_array_get(newOutputs_sources, i$4);
    var k$6 = match$8[1];
    var e$4 = match$8[0];
    var match$9 = Caml_array.caml_array_get(e$4.contents.targets, k$6);
    Caml_array.caml_array_set(e$4.contents.targets, k$6, /* tuple */[
          match$9[0],
          match$9[1] - x | 0
        ]);
  }
  return {
          inputs: {
            contents: newInputs
          },
          edges: h.edges,
          outputs: {
            contents: newOutputs
          }
        };
}

function swapNet(i, x, y) {
  var ine_sources = /* array */[];
  var ine_targets = initialisePorts(x + y | 0);
  var ine = {
    id: 0,
    sources: ine_sources,
    targets: ine_targets,
    label: alpha,
    latex: alphaLatex
  };
  var oute_id = i + 1 | 0;
  var oute_sources = initialisePorts(x + y | 0);
  var oute_targets = /* array */[];
  var oute = {
    id: oute_id,
    sources: oute_sources,
    targets: oute_targets,
    label: omega,
    latex: omegaLatex
  };
  var refin = {
    contents: ine
  };
  var refout = {
    contents: oute
  };
  for(var i$1 = 0 ,i_finish = x - 1 | 0; i$1 <= i_finish; ++i$1){
    Caml_array.caml_array_set(refin.contents.targets, i$1, /* tuple */[
          refout,
          y + i$1 | 0
        ]);
    Caml_array.caml_array_set(refout.contents.sources, y + i$1 | 0, /* tuple */[
          refin,
          i$1
        ]);
  }
  for(var i$2 = x ,i_finish$1 = (x + y | 0) - 1 | 0; i$2 <= i_finish$1; ++i$2){
    Caml_array.caml_array_set(refin.contents.targets, i$2, /* tuple */[
          refout,
          i$2 - x | 0
        ]);
    Caml_array.caml_array_set(refout.contents.sources, i$2 - x | 0, /* tuple */[
          refin,
          i$2
        ]);
  }
  return {
          inputs: refin,
          edges: /* [] */0,
          outputs: refout
        };
}

function delayNet(i, n) {
  var subscript = Helpers$CircuitVisualiser.generateUnicodeSubscript(n);
  return functionNet("ẟ" + subscript, "\\delta_{" + (subscript + "}"), 1, 1, i);
}

function forkNet(i) {
  return functionNet("⋏", forkLatex, 1, 2, i);
}

function dforkNet(i, n) {
  var subscript = Helpers$CircuitVisualiser.generateUnicodeSubscript(n);
  return functionNet("Δ" + subscript, dforkLatex + ("_{" + (subscript + "}")), n, (n << 1), i);
}

function iterHypernet(circuit, i) {
  var n = circuit.outputs.contents.sources.length;
  var nfork = dforkNet(i, n);
  var newCircuit = composeSequential(circuit, nfork[0]);
  return /* tuple */[
          traceHypernet(n, newCircuit),
          nfork[1]
        ];
}

function joinLinks(net, l, outlink, inlink) {
  var outedge = List.hd(findEdges(Circuits$CircuitVisualiser.lookupLink(outlink, l), net));
  var inedge = List.hd(findEdges(Circuits$CircuitVisualiser.lookupLink(inlink, l), net));
  var match = Caml_array.caml_array_get(outedge.contents.sources, 0);
  var k = match[1];
  var e = match[0];
  var match$1 = Caml_array.caml_array_get(inedge.contents.targets, 0);
  var k$prime = match$1[1];
  var e$prime = match$1[0];
  Caml_array.caml_array_set(e.contents.targets, k, /* tuple */[
        e$prime,
        k$prime
      ]);
  Caml_array.caml_array_set(e$prime.contents.sources, k$prime, /* tuple */[
        e,
        k
      ]);
  var newNet = removeEdge(net, outedge);
  return removeEdge(newNet, inedge);
}

function convertCircuitToHypernet$prime(_circuit, i) {
  while(true) {
    var circuit = _circuit;
    var match = circuit.c;
    switch (match.tag | 0) {
      case /* Value */0 :
          var x = match[0];
          var e = { };
          var oute = { };
          Caml_obj.caml_update_dummy(e, {
                contents: {
                  id: i + 1 | 0,
                  sources: /* array */[],
                  targets: /* array */[/* tuple */[
                      oute,
                      0
                    ]],
                  label: Curry._1(circuit.v.print, x),
                  latex: Curry._1(circuit.v.printLatex, x)
                }
              });
          Caml_obj.caml_update_dummy(oute, {
                contents: {
                  id: i + 2 | 0,
                  sources: /* array */[/* tuple */[
                      e,
                      0
                    ]],
                  targets: /* array */[],
                  label: omega,
                  latex: omegaLatex
                }
              });
          var ine = floatingEdge(i, alpha, alphaLatex);
          return /* tuple */[
                  {
                    inputs: ine,
                    edges: /* :: */[
                      e,
                      /* [] */0
                    ],
                    outputs: oute
                  },
                  i + 3 | 0
                ];
      case /* Identity */1 :
          var n = match[0];
          var ine$1 = floatingEdge(i, "", "");
          var oute$1 = {
            contents: {
              id: i + 1 | 0,
              sources: $$Array.init(n, (function(ine$1){
                  return function (n) {
                    return /* tuple */[
                            ine$1,
                            n
                          ];
                  }
                  }(ine$1))),
              targets: /* array */[],
              label: omega,
              latex: omegaLatex
            }
          };
          ine$1.contents = {
            id: 0,
            sources: /* array */[],
            targets: $$Array.init(n, (function(oute$1){
                return function (n) {
                  return /* tuple */[
                          oute$1,
                          n
                        ];
                }
                }(oute$1))),
            label: alpha,
            latex: alphaLatex
          };
          return /* tuple */[
                  {
                    inputs: ine$1,
                    edges: /* [] */0,
                    outputs: oute$1
                  },
                  i + 2 | 0
                ];
      case /* Composition */2 :
          var fh = convertCircuitToHypernet$prime(match[0], i);
          var gh = convertCircuitToHypernet$prime(match[1], fh[1]);
          return /* tuple */[
                  composeSequential(fh[0], gh[0]),
                  gh[1]
                ];
      case /* Tensor */3 :
          var match$1 = match[0];
          if (match$1) {
            return List.fold_left((function (f, g) {
                          var gh = convertCircuitToHypernet$prime(g, f[1]);
                          return /* tuple */[
                                  composeParallel(f[0], gh[0], gh[1]),
                                  gh[1] + 2 | 0
                                ];
                        }), convertCircuitToHypernet$prime(match$1[0], i), match$1[1]);
          } else {
            return Pervasives.failwith("badly formed circuit");
          }
      case /* Swap */4 :
          return /* tuple */[
                  swapNet(i, match[0], match[1]),
                  i + 2 | 0
                ];
      case /* Function */5 :
          return functionNet(match[0], match[1], match[2], match[3], i);
      case /* Delay */6 :
          return delayNet(i, match[0]);
      case /* Trace */7 :
          var match$2 = convertCircuitToHypernet$prime(match[1], i + 1 | 0);
          return /* tuple */[
                  traceHypernet(match[0], match$2[0]),
                  match$2[1]
                ];
      case /* Iter */8 :
          var f = match[1];
          var f$prime = Circuits$CircuitVisualiser.compose(f, Circuits$CircuitVisualiser.dfork(circuit.v, Circuits$CircuitVisualiser.outputs(f)));
          var match$3 = convertCircuitToHypernet$prime(f$prime, i + 1 | 0);
          return /* tuple */[
                  traceHypernet(Circuits$CircuitVisualiser.outputs(f), match$3[0]),
                  match$3[1]
                ];
      case /* Inlink */9 :
          var x$1 = match[0];
          var e$1 = { };
          var oute$2 = { };
          Caml_obj.caml_update_dummy(e$1, {
                contents: {
                  id: i + 1 | 0,
                  sources: /* array */[],
                  targets: /* array */[/* tuple */[
                      oute$2,
                      0
                    ]],
                  label: Circuits$CircuitVisualiser.lookupLink(x$1, circuit.l),
                  latex: Circuits$CircuitVisualiser.lookupLink(x$1, circuit.l)
                }
              });
          Caml_obj.caml_update_dummy(oute$2, {
                contents: {
                  id: i + 2 | 0,
                  sources: /* array */[/* tuple */[
                      e$1,
                      0
                    ]],
                  targets: /* array */[],
                  label: omega,
                  latex: omegaLatex
                }
              });
          var ine$2 = floatingEdge(i, alpha, alphaLatex);
          return /* tuple */[
                  {
                    inputs: ine$2,
                    edges: /* :: */[
                      e$1,
                      /* [] */0
                    ],
                    outputs: oute$2
                  },
                  i + 3 | 0
                ];
      case /* Outlink */10 :
          var x$2 = match[0];
          var e$2 = { };
          var ine$3 = { };
          Caml_obj.caml_update_dummy(e$2, {
                contents: {
                  id: i + 1 | 0,
                  sources: /* array */[/* tuple */[
                      ine$3,
                      0
                    ]],
                  targets: /* array */[],
                  label: Circuits$CircuitVisualiser.lookupLink(x$2, circuit.l),
                  latex: Circuits$CircuitVisualiser.lookupLink(x$2, circuit.l)
                }
              });
          Caml_obj.caml_update_dummy(ine$3, {
                contents: {
                  id: i,
                  sources: /* array */[],
                  targets: /* array */[/* tuple */[
                      e$2,
                      0
                    ]],
                  label: alpha,
                  latex: alphaLatex
                }
              });
          var oute$3 = floatingEdge(i + 2 | 0, omega, omegaLatex);
          return /* tuple */[
                  {
                    inputs: ine$3,
                    edges: /* :: */[
                      e$2,
                      /* [] */0
                    ],
                    outputs: oute$3
                  },
                  i + 3 | 0
                ];
      case /* Link */11 :
          var f$1 = convertCircuitToHypernet$prime(match[2], i);
          return /* tuple */[
                  joinLinks(f$1[0], circuit.l, match[0], match[1]),
                  f$1[1]
                ];
      case /* Macro */12 :
          _circuit = match[2];
          continue ;
      
    }
  };
}

function convertCircuitToHypernet(circuit) {
  return convertCircuitToHypernet$prime(circuit, 0)[0];
}

function reachable$prime(input, output, edge, traversed) {
  if (edge.contents.id === output.id) {
    return true;
  } else if (List.mem(edge.contents.id, traversed)) {
    return false;
  } else {
    var result = false;
    for(var i = 0 ,i_finish = edge.contents.targets.length - 1 | 0; i <= i_finish; ++i){
      result = result || reachable$prime(input, output, Caml_array.caml_array_get(edge.contents.targets, i)[0], Pervasives.$at(traversed, /* :: */[
                edge.contents.id,
                /* [] */0
              ]));
    }
    return result;
  }
}

function reachable(input, output, edge) {
  return reachable$prime(input, output, edge, /* [] */0);
}

function stubEdge(i, e, k) {
  return {
          contents: {
            id: i,
            sources: /* array */[/* tuple */[
                e,
                k
              ]],
            targets: /* array */[],
            label: "~",
            latex: stubLatex
          }
        };
}

function minimise$prime(input, output, edge, traversed) {
  var newStubs = /* [] */0;
  if (edge.contents.id !== output.contents.id && !List.mem(edge.contents.id, traversed)) {
    for(var i = 0 ,i_finish = edge.contents.targets.length - 1 | 0; i <= i_finish; ++i){
      var match = Caml_array.caml_array_get(edge.contents.targets, i);
      var e = match[0];
      if (reachable(input.contents, output.contents, e)) {
        newStubs = Pervasives.$at(newStubs, minimise$prime(input, output, e, Pervasives.$at(traversed, /* :: */[
                      edge.contents.id,
                      /* [] */0
                    ])));
      } else {
        var newStubEdge = stubEdge(Caml_array.caml_array_get(edge.contents.targets, i)[0].contents.id, edge, i);
        Caml_array.caml_array_set(edge.contents.targets, i, /* tuple */[
              newStubEdge,
              0
            ]);
        newStubs = Pervasives.$at(newStubs, /* :: */[
              newStubEdge,
              /* [] */0
            ]);
      }
    }
  }
  return newStubs;
}

function minimise(net) {
  var newStubs = minimise$prime(net.inputs, net.outputs, net.inputs, /* [] */0);
  var edges = Pervasives.$at(List.filter((function (e) {
                return reachable(net.inputs.contents, net.outputs.contents, e);
              }))(net.edges), newStubs);
  return {
          inputs: net.inputs,
          edges: edges,
          outputs: net.outputs
        };
}

var dot = "•";

var joinLatex = "\\curlyvee";

var djoinLatex = "\\nabla";

export {
  alpha ,
  omega ,
  dot ,
  alphaLatex ,
  omegaLatex ,
  stubLatex ,
  forkLatex ,
  joinLatex ,
  dforkLatex ,
  djoinLatex ,
  GraphError ,
  graphError ,
  findEdges ,
  findEdges$prime ,
  printEdge ,
  printEdgeArray ,
  printEdgeRefArray ,
  printEdgeRefPortPairArray ,
  printEdgeRefList ,
  printHypernet ,
  floatingEdge ,
  initialisePorts ,
  zeroNet ,
  identity ,
  removeEdge ,
  removeEdge$prime ,
  composeSequential ,
  composeParallel ,
  functionNet ,
  traceHypernet ,
  swapNet ,
  delayNet ,
  forkNet ,
  dforkNet ,
  iterHypernet ,
  joinLinks ,
  convertCircuitToHypernet ,
  convertCircuitToHypernet$prime ,
  reachable ,
  reachable$prime ,
  stubEdge ,
  minimise ,
  minimise$prime ,
  
}
/* zeroNet Not a pure module */
