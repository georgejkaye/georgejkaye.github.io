// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as $$Array from "../../../node_modules/bs-platform/lib/es6/array.js";
import * as Curry from "../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Caml_obj from "../../../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Caml_array from "../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Pervasives from "../../../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Caml_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_exceptions.js";
import * as Caml_builtin_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as Helpers$CircuitVisualiser from "./Helpers.bs.js";
import * as Circuits$CircuitVisualiser from "./Circuits.bs.js";

var GraphError = Caml_exceptions.create("Hypernets-CircuitVisualiser.GraphError");

function graphError(message) {
  throw [
        GraphError,
        message
      ];
}

function findEdges$prime(string, _edges, _acc) {
  while(true) {
    var acc = _acc;
    var edges = _edges;
    if (edges) {
      var xs = edges[1];
      var x = edges[0];
      var match = x.contents.label === string;
      if (match) {
        _acc = /* :: */[
          x,
          acc
        ];
        _edges = xs;
        continue ;
      } else {
        _edges = xs;
        continue ;
      }
    } else {
      return acc;
    }
  };
}

function findEdges(string, net) {
  return findEdges$prime(string, net.edges, /* [] */0);
}

function printEdgeRefPortPairArray(es) {
  return Helpers$CircuitVisualiser.printArray(es, (function (param) {
                return param[0].contents.label + (":" + String(param[1]));
              }));
}

function printEdge(e) {
  return "edge " + (String(e.id) + (": " + (e.label + (", sources: " + (printEdgeRefPortPairArray(e.sources) + (", targets: " + printEdgeRefPortPairArray(e.targets)))))));
}

function printEdgeArray(es) {
  return Helpers$CircuitVisualiser.printArray(es, printEdge);
}

function printEdgeRefArray(es) {
  return Helpers$CircuitVisualiser.printArray(es, (function (x) {
                return printEdge(x.contents);
              }));
}

function printEdgeRefList(es) {
  return Helpers$CircuitVisualiser.printList(es, (function (x) {
                return printEdge(x.contents);
              }));
}

function printHypernet(h) {
  return "hypernet inputs " + (printEdge(h.inputs) + (", outputs " + (printEdge(h.outputs) + (", edges " + printEdgeRefList(h.edges)))));
}

function floatingEdge(id, label) {
  return {
          id: id,
          sources: /* array */[],
          targets: /* array */[],
          label: label
        };
}

function initialisePorts(x) {
  return $$Array.init(x, (function (i) {
                return /* tuple */[
                        {
                          contents: {
                            id: 0,
                            sources: /* array */[],
                            targets: /* array */[],
                            label: ""
                          }
                        },
                        i
                      ];
              }));
}

var zeroNet_inputs = {
  id: 0,
  sources: /* array */[],
  targets: /* array */[],
  label: "in"
};

var zeroNet_outputs = {
  id: 1,
  sources: /* array */[],
  targets: /* array */[],
  label: "out"
};

var zeroNet = {
  inputs: zeroNet_inputs,
  edges: /* [] */0,
  outputs: zeroNet_outputs
};

function identity(array) {
  return array;
}

function removeEdge$prime(edge, _edges, _acc) {
  while(true) {
    var acc = _acc;
    var edges = _edges;
    if (edges) {
      var xs = edges[1];
      var x = edges[0];
      var match = x.contents.id === edge.contents.id;
      if (match) {
        return Pervasives.$at(acc, xs);
      } else {
        _acc = /* :: */[
          x,
          acc
        ];
        _edges = xs;
        continue ;
      }
    } else {
      return acc;
    }
  };
}

function removeEdge(param, edge) {
  return {
          inputs: param.inputs,
          edges: removeEdge$prime(edge, param.edges, /* [] */0),
          outputs: param.outputs
        };
}

function composeSequential(f, g) {
  if (f.outputs.sources.length !== g.inputs.targets.length) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Hypernets.re",
            58,
            4
          ]
        ];
  }
  for(var i = 0 ,i_finish = f.outputs.sources.length - 1 | 0; i <= i_finish; ++i){
    var match = Caml_array.caml_array_get(f.outputs.sources, i);
    var k = match[1];
    var e = match[0];
    var match$1 = Caml_array.caml_array_get(g.inputs.targets, i);
    var k$prime = match$1[1];
    var e$prime = match$1[0];
    Caml_array.caml_array_set(e.contents.targets, k, /* tuple */[
          e$prime,
          k$prime
        ]);
    Caml_array.caml_array_set(e$prime.contents.sources, k$prime, /* tuple */[
          e,
          k
        ]);
  }
  return {
          inputs: f.inputs,
          edges: Pervasives.$at(f.edges, g.edges),
          outputs: g.outputs
        };
}

function composeParallel(f, g, i) {
  var newInputs_sources = /* array */[];
  var newInputs_targets = $$Array.append(f.inputs.targets, g.inputs.targets);
  var newInputs = {
    id: 0,
    sources: newInputs_sources,
    targets: newInputs_targets,
    label: "in"
  };
  var newOutputs_id = i + 1 | 0;
  var newOutputs_sources = $$Array.append(f.outputs.sources, g.outputs.sources);
  var newOutputs_targets = /* array */[];
  var newOutputs = {
    id: newOutputs_id,
    sources: newOutputs_sources,
    targets: newOutputs_targets,
    label: "out"
  };
  var finputs = f.inputs.targets.length;
  var foutputs = f.outputs.sources.length;
  var refInputs = {
    contents: newInputs
  };
  var refOutputs = {
    contents: newOutputs
  };
  for(var i$1 = 0 ,i_finish = f.inputs.targets.length - 1 | 0; i$1 <= i_finish; ++i$1){
    var match = Caml_array.caml_array_get(f.inputs.targets, i$1);
    var k = match[1];
    var e = match[0];
    var match$1 = e.contents.label === "out";
    if (match$1) {
      Caml_array.caml_array_set(refOutputs.contents.sources, k, /* tuple */[
            refInputs,
            i$1
          ]);
    } else {
      Caml_array.caml_array_set(e.contents.sources, k, /* tuple */[
            refInputs,
            i$1
          ]);
    }
  }
  for(var i$2 = 0 ,i_finish$1 = g.inputs.targets.length - 1 | 0; i$2 <= i_finish$1; ++i$2){
    var match$2 = Caml_array.caml_array_get(g.inputs.targets, i$2);
    var k$1 = match$2[1];
    var e$1 = match$2[0];
    var match$3 = e$1.contents.label === "out";
    if (match$3) {
      Caml_array.caml_array_set(refOutputs.contents.sources, k$1 + foutputs | 0, /* tuple */[
            refInputs,
            i$2 + finputs | 0
          ]);
    } else {
      Caml_array.caml_array_set(e$1.contents.sources, k$1, /* tuple */[
            refInputs,
            i$2 + finputs | 0
          ]);
    }
  }
  for(var i$3 = 0 ,i_finish$2 = f.outputs.sources.length - 1 | 0; i$3 <= i_finish$2; ++i$3){
    var match$4 = Caml_array.caml_array_get(f.outputs.sources, i$3);
    var k$2 = match$4[1];
    var e$2 = match$4[0];
    var match$5 = e$2.contents.label === "in";
    if (match$5) {
      Caml_array.caml_array_set(refInputs.contents.targets, k$2, /* tuple */[
            refOutputs,
            i$3
          ]);
    } else {
      Caml_array.caml_array_set(e$2.contents.targets, k$2, /* tuple */[
            refOutputs,
            i$3
          ]);
    }
  }
  for(var i$4 = 0 ,i_finish$3 = g.outputs.sources.length - 1 | 0; i$4 <= i_finish$3; ++i$4){
    var match$6 = Caml_array.caml_array_get(g.outputs.sources, i$4);
    var k$3 = match$6[1];
    var e$3 = match$6[0];
    var match$7 = e$3.contents.label === "in";
    if (match$7) {
      Caml_array.caml_array_set(refInputs.contents.targets, k$3 + finputs | 0, /* tuple */[
            refOutputs,
            i$4 + foutputs | 0
          ]);
    } else {
      Caml_array.caml_array_set(e$3.contents.targets, k$3, /* tuple */[
            refOutputs,
            i$4 + foutputs | 0
          ]);
    }
  }
  return {
          inputs: refInputs.contents,
          edges: Pervasives.$at(f.edges, g.edges),
          outputs: refOutputs.contents
        };
}

function functionNet(id, ins, outs, i) {
  var ine = {
    contents: floatingEdge(i, "")
  };
  var oute = {
    contents: floatingEdge(i + 2 | 0, "")
  };
  var fune = {
    contents: {
      id: i + 1 | 0,
      sources: $$Array.init(ins, (function (n) {
              return /* tuple */[
                      ine,
                      n
                    ];
            })),
      targets: $$Array.init(outs, (function (n) {
              return /* tuple */[
                      oute,
                      n
                    ];
            })),
      label: id
    }
  };
  ine.contents = {
    id: 0,
    sources: /* array */[],
    targets: $$Array.init(ins, (function (n) {
            return /* tuple */[
                    fune,
                    n
                  ];
          })),
    label: "in"
  };
  oute.contents = {
    id: i + 2 | 0,
    sources: $$Array.init(outs, (function (n) {
            return /* tuple */[
                    fune,
                    n
                  ];
          })),
    targets: /* array */[],
    label: "out"
  };
  return /* tuple */[
          {
            inputs: ine.contents,
            edges: /* :: */[
              fune,
              /* [] */0
            ],
            outputs: oute.contents
          },
          i + 3 | 0
        ];
}

function traceHypernet(x, h) {
  for(var i = 0 ,i_finish = x - 1 | 0; i <= i_finish; ++i){
    var match = Caml_array.caml_array_get(h.inputs.targets, i);
    var k = match[1];
    var e = match[0];
    var match$1 = Caml_array.caml_array_get(h.outputs.sources, i);
    var k$prime = match$1[1];
    var e$prime = match$1[0];
    Caml_array.caml_array_set(e$prime.contents.targets, k$prime, /* tuple */[
          e,
          k
        ]);
    Caml_array.caml_array_set(e.contents.sources, k, /* tuple */[
          e$prime,
          k$prime
        ]);
  }
  var newInputs_sources = /* array */[];
  var newInputs_targets = $$Array.sub(h.inputs.targets, x, h.inputs.targets.length - x | 0);
  var newInputs = {
    id: 0,
    sources: newInputs_sources,
    targets: newInputs_targets,
    label: "in"
  };
  var newOutputs_id = h.outputs.id;
  var newOutputs_sources = $$Array.sub(h.outputs.sources, x, h.outputs.sources.length - x | 0);
  var newOutputs_targets = /* array */[];
  var newOutputs = {
    id: newOutputs_id,
    sources: newOutputs_sources,
    targets: newOutputs_targets,
    label: "out"
  };
  for(var i$1 = 0 ,i_finish$1 = newInputs_targets.length - 1 | 0; i$1 <= i_finish$1; ++i$1){
    var match$2 = Caml_array.caml_array_get(newInputs_targets, i$1);
    var k$1 = match$2[1];
    var e$1 = match$2[0];
    var match$3 = e$1.contents.label === "out";
    var k$2 = match$3 ? k$1 - x | 0 : k$1;
    Caml_array.caml_array_set(newInputs_targets, i$1, /* tuple */[
          e$1,
          k$2
        ]);
  }
  for(var i$2 = 0 ,i_finish$2 = newOutputs_targets.length - 1 | 0; i$2 <= i_finish$2; ++i$2){
    var match$4 = Caml_array.caml_array_get(newInputs_sources, i$2);
    var k$3 = match$4[1];
    var e$2 = match$4[0];
    var match$5 = e$2.contents.label === "in";
    var k$4 = match$5 ? k$3 - x | 0 : k$3;
    Caml_array.caml_array_set(newInputs_sources, i$2, /* tuple */[
          e$2,
          k$4
        ]);
  }
  for(var i$3 = 0 ,i_finish$3 = newInputs_targets.length - 1 | 0; i$3 <= i_finish$3; ++i$3){
    var match$6 = Caml_array.caml_array_get(newInputs_targets, i$3);
    var k$5 = match$6[1];
    var e$3 = match$6[0];
    var match$7 = Caml_array.caml_array_get(e$3.contents.sources, k$5);
    Caml_array.caml_array_set(e$3.contents.sources, k$5, /* tuple */[
          match$7[0],
          match$7[1] - x | 0
        ]);
  }
  for(var i$4 = 0 ,i_finish$4 = newOutputs_sources.length - 1 | 0; i$4 <= i_finish$4; ++i$4){
    var match$8 = Caml_array.caml_array_get(newOutputs_sources, i$4);
    var k$6 = match$8[1];
    var e$4 = match$8[0];
    var match$9 = Caml_array.caml_array_get(e$4.contents.targets, k$6);
    Caml_array.caml_array_set(e$4.contents.targets, k$6, /* tuple */[
          match$9[0],
          match$9[1] - x | 0
        ]);
  }
  return {
          inputs: newInputs,
          edges: h.edges,
          outputs: newOutputs
        };
}

function swapNet(i, x, y) {
  var ine_sources = /* array */[];
  var ine_targets = initialisePorts(x + y | 0);
  var ine = {
    id: 0,
    sources: ine_sources,
    targets: ine_targets,
    label: "in"
  };
  var oute_id = i + 1 | 0;
  var oute_sources = initialisePorts(x + y | 0);
  var oute_targets = /* array */[];
  var oute = {
    id: oute_id,
    sources: oute_sources,
    targets: oute_targets,
    label: "out"
  };
  var refin = {
    contents: ine
  };
  var refout = {
    contents: oute
  };
  for(var i$1 = 0 ,i_finish = x - 1 | 0; i$1 <= i_finish; ++i$1){
    Caml_array.caml_array_set(refin.contents.targets, i$1, /* tuple */[
          refout,
          y + i$1 | 0
        ]);
    Caml_array.caml_array_set(refout.contents.sources, y + i$1 | 0, /* tuple */[
          refin,
          i$1
        ]);
  }
  for(var i$2 = x ,i_finish$1 = (x + y | 0) - 1 | 0; i$2 <= i_finish$1; ++i$2){
    Caml_array.caml_array_set(refin.contents.targets, i$2, /* tuple */[
          refout,
          i$2 - x | 0
        ]);
    Caml_array.caml_array_set(refout.contents.sources, i$2 - x | 0, /* tuple */[
          refin,
          i$2
        ]);
  }
  return {
          inputs: refin.contents,
          edges: /* [] */0,
          outputs: refout.contents
        };
}

function delayNet(i, n) {
  var subscript = Helpers$CircuitVisualiser.generateUnicodeSubscript(n);
  return functionNet("ẟ" + subscript, 1, 1, i);
}

function forkNet(i) {
  return functionNet("⋏", 1, 2, i);
}

function dforkNet(i, n) {
  var subscript = Helpers$CircuitVisualiser.generateUnicodeSubscript(n);
  return functionNet("Δ" + subscript, n, (n << 1), i);
}

function iterHypernet(circuit, i) {
  var n = circuit.outputs.sources.length;
  var nfork = dforkNet(i, n);
  var newCircuit = composeSequential(circuit, nfork[0]);
  return /* tuple */[
          traceHypernet(n, newCircuit),
          nfork[1]
        ];
}

function joinLinks(net, l, outlink, inlink) {
  var outedge = List.hd(findEdges(Circuits$CircuitVisualiser.lookupLink(outlink, l), net));
  var inedge = List.hd(findEdges(Circuits$CircuitVisualiser.lookupLink(inlink, l), net));
  var match = Caml_array.caml_array_get(outedge.contents.sources, 0);
  var k = match[1];
  var e = match[0];
  var match$1 = Caml_array.caml_array_get(inedge.contents.targets, 0);
  var k$prime = match$1[1];
  var e$prime = match$1[0];
  Caml_array.caml_array_set(e.contents.targets, k, /* tuple */[
        e$prime,
        k$prime
      ]);
  Caml_array.caml_array_set(e$prime.contents.sources, k$prime, /* tuple */[
        e,
        k
      ]);
  var newNet = removeEdge(net, outedge);
  return removeEdge(newNet, inedge);
}

function convertCircuitToHypernet$prime(_circuit, i) {
  while(true) {
    var circuit = _circuit;
    console.log(Circuits$CircuitVisualiser.printCircuit(circuit));
    var match = circuit.c;
    switch (match.tag | 0) {
      case /* Value */0 :
          var e = { };
          var oute = { };
          Caml_obj.caml_update_dummy(e, {
                contents: {
                  id: i + 1 | 0,
                  sources: /* array */[],
                  targets: /* array */[/* tuple */[
                      oute,
                      0
                    ]],
                  label: Curry._1(circuit.v.print, match[0])
                }
              });
          Caml_obj.caml_update_dummy(oute, {
                contents: {
                  id: i + 2 | 0,
                  sources: /* array */[/* tuple */[
                      e,
                      0
                    ]],
                  targets: /* array */[],
                  label: "out"
                }
              });
          var ine = floatingEdge(i, "in");
          return /* tuple */[
                  {
                    inputs: ine,
                    edges: /* :: */[
                      e,
                      /* [] */0
                    ],
                    outputs: oute.contents
                  },
                  i + 3 | 0
                ];
      case /* Identity */1 :
          var n = match[0];
          var ine$1 = {
            contents: floatingEdge(i, "")
          };
          var oute$1 = {
            contents: {
              id: i + 1 | 0,
              sources: $$Array.init(n, (function(ine$1){
                  return function (n) {
                    return /* tuple */[
                            ine$1,
                            n
                          ];
                  }
                  }(ine$1))),
              targets: /* array */[],
              label: "out"
            }
          };
          ine$1.contents = {
            id: 0,
            sources: /* array */[],
            targets: $$Array.init(n, (function(oute$1){
                return function (n) {
                  return /* tuple */[
                          oute$1,
                          n
                        ];
                }
                }(oute$1))),
            label: "in"
          };
          return /* tuple */[
                  {
                    inputs: ine$1.contents,
                    edges: /* [] */0,
                    outputs: oute$1.contents
                  },
                  i + 2 | 0
                ];
      case /* Composition */2 :
          var fh = convertCircuitToHypernet$prime(match[0], i);
          var gh = convertCircuitToHypernet$prime(match[1], fh[1]);
          return /* tuple */[
                  composeSequential(fh[0], gh[0]),
                  gh[1]
                ];
      case /* Tensor */3 :
          var match$1 = match[0];
          if (match$1) {
            return List.fold_left((function (f, g) {
                          var gh = convertCircuitToHypernet$prime(g, f[1]);
                          return /* tuple */[
                                  composeParallel(f[0], gh[0], gh[1]),
                                  gh[1] + 2 | 0
                                ];
                        }), convertCircuitToHypernet$prime(match$1[0], i), match$1[1]);
          } else {
            return Pervasives.failwith("badly formed circuit");
          }
      case /* Swap */4 :
          return /* tuple */[
                  swapNet(i, match[0], match[1]),
                  i + 2 | 0
                ];
      case /* Function */5 :
          return functionNet(match[0], match[2], match[3], i);
      case /* Delay */6 :
          return delayNet(i, match[0]);
      case /* Trace */7 :
          var match$2 = convertCircuitToHypernet$prime(match[1], i + 1 | 0);
          return /* tuple */[
                  traceHypernet(match[0], match$2[0]),
                  match$2[1]
                ];
      case /* Iter */8 :
          var f = match[1];
          var f$prime = Circuits$CircuitVisualiser.compose(f, Circuits$CircuitVisualiser.dfork(circuit.v, Circuits$CircuitVisualiser.outputs(f)));
          var match$3 = convertCircuitToHypernet$prime(f$prime, i + 1 | 0);
          return /* tuple */[
                  traceHypernet(Circuits$CircuitVisualiser.outputs(f), match$3[0]),
                  match$3[1]
                ];
      case /* Inlink */9 :
          var e$1 = { };
          var oute$2 = { };
          Caml_obj.caml_update_dummy(e$1, {
                contents: {
                  id: i + 1 | 0,
                  sources: /* array */[],
                  targets: /* array */[/* tuple */[
                      oute$2,
                      0
                    ]],
                  label: Circuits$CircuitVisualiser.lookupLink(match[0], circuit.l)
                }
              });
          Caml_obj.caml_update_dummy(oute$2, {
                contents: {
                  id: i + 2 | 0,
                  sources: /* array */[/* tuple */[
                      e$1,
                      0
                    ]],
                  targets: /* array */[],
                  label: "out"
                }
              });
          var ine$2 = floatingEdge(i, "in");
          return /* tuple */[
                  {
                    inputs: ine$2,
                    edges: /* :: */[
                      e$1,
                      /* [] */0
                    ],
                    outputs: oute$2.contents
                  },
                  i + 3 | 0
                ];
      case /* Outlink */10 :
          var e$2 = { };
          var ine$3 = { };
          Caml_obj.caml_update_dummy(e$2, {
                contents: {
                  id: i + 1 | 0,
                  sources: /* array */[/* tuple */[
                      ine$3,
                      0
                    ]],
                  targets: /* array */[],
                  label: Circuits$CircuitVisualiser.lookupLink(match[0], circuit.l)
                }
              });
          Caml_obj.caml_update_dummy(ine$3, {
                contents: {
                  id: i,
                  sources: /* array */[],
                  targets: /* array */[/* tuple */[
                      e$2,
                      0
                    ]],
                  label: "in"
                }
              });
          var oute$3 = floatingEdge(i + 2 | 0, "out");
          return /* tuple */[
                  {
                    inputs: ine$3.contents,
                    edges: /* :: */[
                      e$2,
                      /* [] */0
                    ],
                    outputs: oute$3
                  },
                  i + 3 | 0
                ];
      case /* Link */11 :
          var f$1 = convertCircuitToHypernet$prime(match[2], i);
          return /* tuple */[
                  joinLinks(f$1[0], circuit.l, match[0], match[1]),
                  f$1[1]
                ];
      case /* Macro */12 :
          _circuit = match[2];
          continue ;
      
    }
  };
}

function convertCircuitToHypernet(circuit) {
  return convertCircuitToHypernet$prime(circuit, 0)[0];
}

var tab = "    ";

function getTraceText(x, e, left) {
  var dir = left ? "l" : "r";
  var name = "trace" + (dir + (String(x) + ("to" + String(e.contents.id))));
  return /* tuple */[
          name,
          name + "[shape=point, width=0.01]\n"
        ];
}

function generateGraphvizCodeEdges(inputs, outputs, _edges, _ranks, _nodes, _traces, _transitions) {
  while(true) {
    var transitions = _transitions;
    var traces = _traces;
    var nodes = _nodes;
    var ranks = _ranks;
    var edges = _edges;
    var inid = inputs.id;
    var outid = outputs.id;
    if (edges) {
      var edgecode = generateGraphvizCodeEdge(edges[0], inid, outid);
      var match = edgecode[0] === "";
      var edgedot = match ? "" : edgecode[0] + ";\n";
      var ranksdot = Caml_array.caml_array_get(edgecode[1], 0);
      var tracedot = Caml_array.caml_array_get(edgecode[1], 1);
      var transdot = Caml_array.caml_array_get(edgecode[1], 2);
      _transitions = transitions + transdot;
      _traces = traces + tracedot;
      _nodes = nodes + edgedot;
      _ranks = ranks + ranksdot;
      _edges = edges[1];
      continue ;
    } else {
      var match$1;
      if (inputs.targets.length === 0) {
        match$1 = /* tuple */[
          "",
          ""
        ];
      } else {
        var inedgecode = generateGraphvizCodeEdge(inputs, inid, outid);
        var match$2 = inedgecode[0] === "";
        var edgedot$1 = match$2 ? "" : inedgecode[0] + ";\n";
        var transdot$1 = Caml_array.caml_array_get(inedgecode[1], 2);
        match$1 = /* tuple */[
          edgedot$1,
          transdot$1
        ];
      }
      var match$3;
      if (outputs.sources.length === 0) {
        match$3 = /* tuple */[
          "",
          ""
        ];
      } else {
        var outedgecode = generateGraphvizCodeEdge(outputs, inid, outid);
        var match$4 = outedgecode[0] === "";
        var edgedot$2 = match$4 ? "" : outedgecode[0] + ";\n";
        var transdot$2 = Caml_array.caml_array_get(outedgecode[1], 2);
        match$3 = /* tuple */[
          edgedot$2,
          transdot$2
        ];
      }
      return ranks + (nodes + (match$3[0] + (match$1[0] + ("\n" + (match$1[1] + (traces + (transitions + match$3[1])))))));
    }
  };
}

function generatePorts$prime(x, n, out) {
  var y = out ? "o" : "i";
  if (n !== 0) {
    if (n !== 1) {
      return "<" + (y + (String(x) + ("> " + ("•" + (" | " + generatePorts$prime(x + 1 | 0, n - 1 | 0, out))))));
    } else {
      return "<" + (y + (String(x) + ("> " + "•")));
    }
  } else {
    return "";
  }
}

function generateGraphvizCodeEdge(edge, inid, outid) {
  var ins = edge.sources.length;
  var outs = edge.targets.length;
  var inports = generatePorts(ins, false);
  var outports = generatePorts(outs, true);
  var transitionsdata = generateTransitions(edge.id, inid, outid, edge.targets);
  var match = inports === "{}";
  var instring = match ? "" : inports + " | ";
  var match$1 = outports === "{}";
  var outstring = match$1 ? "" : " | " + outports;
  return /* tuple */[
          tab + ("edge" + (String(edge.id) + (" [shape=Mrecord; label=\"{" + (instring + (edge.label + (outstring + "}\"]")))))),
          transitionsdata
        ];
}

function generatePorts(n, out) {
  return "{" + (generatePorts$prime(0, n, out) + "}");
}

function generateTransitions(x, inid, outid, targets) {
  var string = "";
  var tracenodes = "";
  var ranks = "";
  for(var i = 0 ,i_finish = targets.length - 1 | 0; i <= i_finish; ++i){
    var match = Caml_array.caml_array_get(targets, i);
    var k = match[1];
    var e = match[0];
    if (e.contents.id < x) {
      console.log("trace!");
      var match$1 = getTraceText(x, e, true);
      var idl = match$1[0];
      var match$2 = getTraceText(x, e, false);
      var idr = match$2[0];
      tracenodes = tracenodes + (tab + (match$1[1] + match$2[1]));
      string = string + (tab + ("edge" + (String(x) + (":o" + (String(i) + (":e -> " + (idr + (":s;\n" + (tab + (idr + (":n -> " + (idl + (":n;\n" + (tab + (idl + (":s -> edge" + (String(e.contents.id) + (":i" + (String(k) + ":w;\n")))))))))))))))))));
      ranks = ranks + (tab + ("{rank=same; edge" + (String(inid) + (", " + (idl + ("}\n" + (tab + ("{rank=same; edge" + (String(outid) + (", " + (idr + "}\n")))))))))));
    } else {
      string = string + (tab + ("edge" + (String(x) + (":o" + (String(i) + (":e -> edge" + (String(e.contents.id) + (":i" + (String(k) + ":w;\n")))))))));
    }
  }
  return /* array */[
          ranks,
          tracenodes,
          string
        ];
}

function generateGraphvizCode(net) {
  var graph = generateGraphvizCodeEdges(net.inputs, net.outputs, List.map((function (x) {
              return x.contents;
            }), net.edges), "", "", "", "");
  return "digraph{\n" + (tab + ("rankdir=LR;\n" + (tab + ("ranksep=1;\n" + (graph + "}")))));
}

var zeroDot = generateGraphvizCode(zeroNet);

console.log(zeroDot);

function scanList(_seen, id) {
  while(true) {
    var seen = _seen;
    if (seen) {
      var match = seen[0];
      var match$1 = Caml_obj.caml_equal(match[0], id);
      if (match$1) {
        return /* tuple */[
                true,
                match[1],
                match[2]
              ];
      } else {
        _seen = seen[1];
        continue ;
      }
    } else {
      return /* tuple */[
              false,
              -1,
              -1
            ];
    }
  };
}

function generateTensor$prime(v, _es, _t, _es_next, _outs) {
  while(true) {
    var outs = _outs;
    var es_next = _es_next;
    var t = _t;
    var es = _es;
    if (es) {
      var xs = es[1];
      var match = es[0];
      var e = match[0];
      var e$prime = e.contents;
      var match$1 = e$prime.label === "out";
      if (match$1) {
        _outs = outs + 1 | 0;
        _es_next = $$Array.append(es_next, /* array */[/* tuple */[
                e,
                match[1]
              ]]);
        _t = /* :: */[
          Circuits$CircuitVisualiser.idcirc(v, 1),
          t
        ];
        _es = xs;
        continue ;
      } else {
        _es_next = $$Array.append(es_next, e$prime.targets);
        _t = /* :: */[
          Circuits$CircuitVisualiser.funcBlackBox(v, e$prime.label, "\\text{" + (e$prime.label + "}"), e$prime.sources.length, e$prime.targets.length),
          t
        ];
        _es = xs;
        continue ;
      }
    } else {
      return /* tuple */[
              List.rev(t),
              es_next,
              outs
            ];
    }
  };
}

function generateTensor(v, es) {
  return generateTensor$prime(v, es, /* [] */0, /* array */[], 0);
}

function convertHypernetToEquation(v, net) {
  var cat = /* [] */0;
  var es_next = /* array */[];
  es_next = net.inputs.targets;
  while(es_next.length !== 0) {
    var es = es_next;
    var match = generateTensor(v, $$Array.to_list(es));
    var es_next$prime = match[1];
    if (match[2] === es_next$prime.length) {
      es_next = /* array */[];
    } else {
      es_next = es_next$prime;
      cat = List.append(cat, /* :: */[
            Circuits$CircuitVisualiser.tensor(match[0]),
            /* [] */0
          ]);
    }
  };
  console.log(Circuits$CircuitVisualiser.printCircuitListCommas(cat));
  return Circuits$CircuitVisualiser.composemany(cat);
}

export {
  GraphError ,
  graphError ,
  findEdges ,
  findEdges$prime ,
  printEdge ,
  printEdgeArray ,
  printEdgeRefArray ,
  printEdgeRefPortPairArray ,
  printEdgeRefList ,
  printHypernet ,
  floatingEdge ,
  initialisePorts ,
  zeroNet ,
  identity ,
  removeEdge ,
  removeEdge$prime ,
  composeSequential ,
  composeParallel ,
  functionNet ,
  traceHypernet ,
  swapNet ,
  delayNet ,
  forkNet ,
  dforkNet ,
  iterHypernet ,
  joinLinks ,
  convertCircuitToHypernet ,
  convertCircuitToHypernet$prime ,
  tab ,
  getTraceText ,
  generateGraphvizCode ,
  generateGraphvizCodeEdges ,
  generateGraphvizCodeEdge ,
  generatePorts ,
  generatePorts$prime ,
  generateTransitions ,
  zeroDot ,
  scanList ,
  generateTensor ,
  generateTensor$prime ,
  convertHypernetToEquation ,
  
}
/* zeroDot Not a pure module */
