// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Caml_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_exceptions.js";

var LatticeError = Caml_exceptions.create("Lattices-CircuitVisualiser.LatticeError");

function latticeError(msg) {
  throw [
        LatticeError,
        msg
      ];
}

var simpleLatticeElems = /* :: */[
  /* tuple */[
    0,
    0
  ],
  /* :: */[
    /* tuple */[
      1,
      0
    ],
    /* :: */[
      /* tuple */[
        1,
        1
      ],
      /* :: */[
        /* tuple */[
          2,
          0
        ],
        /* [] */0
      ]
    ]
  ]
];

function simpleLeq(a, b) {
  switch (a[0]) {
    case 0 :
        if (a[1] === 0) {
          return true;
        }
        break;
    case 1 :
        var match = a[1];
        if (match !== 0) {
          if (match === 1 && b[0] === 1) {
            if ((b[1] >>> 0) > 1) {
              throw [
                    LatticeError,
                    "not a lattice element"
                  ];
            } else {
              return true;
            }
          }
          
        } else if (b[0] === 1) {
          if ((b[1] >>> 0) > 1) {
            throw [
                  LatticeError,
                  "not a lattice element"
                ];
          } else {
            return true;
          }
        }
        break;
    case 2 :
        if (a[1] === 0) {
          return false;
        }
        break;
    default:
      
  }
  var match$1 = b[0];
  switch (match$1) {
    case 0 :
        if (b[1] !== 0) {
          throw [
                LatticeError,
                "not a lattice element"
              ];
        } else {
          return false;
        }
    case 1 :
        throw [
              LatticeError,
              "not a lattice element"
            ];
    case 2 :
        if (b[1] !== 0) {
          throw [
                LatticeError,
                "not a lattice element"
              ];
        } else {
          return true;
        }
    default:
      throw [
            LatticeError,
            "not a lattice element"
          ];
  }
}

function printSimpleLattice(elem) {
  switch (elem[0]) {
    case 0 :
        if (elem[1] !== 0) {
          throw [
                LatticeError,
                "not a lattice element"
              ];
        } else {
          return "\xe2\x8a\xa5";
        }
    case 1 :
        var match = elem[1];
        if (match !== 0) {
          if (match !== 1) {
            throw [
                  LatticeError,
                  "not a lattice element"
                ];
          } else {
            return "t";
          }
        } else {
          return "f";
        }
    case 2 :
        if (elem[1] !== 0) {
          throw [
                LatticeError,
                "not a lattice element"
              ];
        } else {
          return "T";
        }
    default:
      throw [
            LatticeError,
            "not a lattice element"
          ];
  }
}

function simpleJoin(a, b) {
  var match = a[0];
  var exit = 0;
  var exit$1 = 0;
  var exit$2 = 0;
  if (match !== 2 || a[1] !== 0) {
    exit$2 = 4;
  } else {
    return /* tuple */[
            2,
            0
          ];
  }
  if (exit$2 === 4) {
    if (b[0] !== 2 || b[1] !== 0) {
      exit$1 = 3;
    } else {
      return /* tuple */[
              2,
              0
            ];
    }
  }
  if (exit$1 === 3) {
    if (match !== 0 || a[1] !== 0) {
      exit = 2;
    } else {
      return b;
    }
  }
  if (exit === 2 && b[0] === 0 && b[1] === 0) {
    return a;
  }
  if (match !== 1) {
    throw [
          LatticeError,
          "not a lattice element"
        ];
  }
  var match$1 = a[1];
  if (match$1 !== 0) {
    if (match$1 !== 1) {
      throw [
            LatticeError,
            "not a lattice element"
          ];
    } else {
      return /* tuple */[
              1,
              1
            ];
    }
  } else {
    return /* tuple */[
            1,
            0
          ];
  }
}

function simpleMeet(a, b) {
  var match = a[0];
  var exit = 0;
  var exit$1 = 0;
  var exit$2 = 0;
  if (match !== 0 || a[1] !== 0) {
    exit$2 = 4;
  } else {
    return /* tuple */[
            0,
            0
          ];
  }
  if (exit$2 === 4) {
    if (b[0] !== 0 || b[1] !== 0) {
      exit$1 = 3;
    } else {
      return /* tuple */[
              0,
              0
            ];
    }
  }
  if (exit$1 === 3) {
    if (match !== 2 || a[1] !== 0) {
      exit = 2;
    } else {
      return b;
    }
  }
  if (exit === 2 && b[0] === 2 && b[1] === 0) {
    return a;
  }
  if (match !== 1) {
    throw [
          LatticeError,
          "not a lattice element"
        ];
  }
  var match$1 = a[1];
  if (match$1 !== 0) {
    if (match$1 !== 1) {
      throw [
            LatticeError,
            "not a lattice element"
          ];
    } else {
      return /* tuple */[
              1,
              1
            ];
    }
  } else {
    return /* tuple */[
            1,
            0
          ];
  }
}

function simpleAnd(a, b) {
  var match = a[0];
  var exit = 0;
  var exit$1 = 0;
  switch (match) {
    case 0 :
        if (a[1] !== 0) {
          exit$1 = 3;
        } else {
          return /* tuple */[
                  0,
                  0
                ];
        }
        break;
    case 1 :
        exit$1 = 3;
        break;
    case 2 :
        if (a[1] !== 0 || b[0] !== 2) {
          exit$1 = 3;
        } else if (b[1] !== 0) {
          throw [
                LatticeError,
                "not a lattice element"
              ];
        } else {
          return /* tuple */[
                  2,
                  0
                ];
        }
        break;
    default:
      exit$1 = 3;
  }
  if (exit$1 === 3) {
    var match$1 = b[0];
    if (match$1 !== 0) {
      if (match$1 !== 1 || b[1] !== 0) {
        exit = 2;
      } else {
        return /* tuple */[
                1,
                0
              ];
      }
    } else if (b[1] !== 0) {
      exit = 2;
    } else {
      return /* tuple */[
              0,
              0
            ];
    }
  }
  if (exit === 2 && match === 1) {
    var match$2 = a[1];
    if (match$2 !== 0) {
      if (match$2 === 1) {
        return b;
      }
      
    } else {
      return /* tuple */[
              1,
              0
            ];
    }
  }
  if (b[0] !== 1) {
    throw [
          LatticeError,
          "not a lattice element"
        ];
  }
  if (b[1] !== 1) {
    throw [
          LatticeError,
          "not a lattice element"
        ];
  }
  return a;
}

function simpleOr(a, b) {
  var match = a[0];
  var exit = 0;
  var exit$1 = 0;
  if (match !== 1) {
    exit$1 = 3;
  } else {
    var match$1 = a[1];
    if (match$1 !== 0) {
      if (match$1 !== 1) {
        exit$1 = 3;
      } else {
        return /* tuple */[
                1,
                1
              ];
      }
    } else if (b[0] !== 1 || b[1] !== 0) {
      exit$1 = 3;
    } else {
      return /* tuple */[
              1,
              0
            ];
    }
  }
  if (exit$1 === 3) {
    var match$2 = b[0];
    if (match$2 !== 0) {
      if (match$2 !== 1 || b[1] !== 1) {
        exit = 2;
      } else {
        return /* tuple */[
                1,
                1
              ];
      }
    } else if (b[1] !== 0) {
      exit = 2;
    } else {
      return /* tuple */[
              0,
              0
            ];
    }
  }
  if (exit === 2) {
    switch (match) {
      case 0 :
          if (a[1] === 0) {
            return /* tuple */[
                    0,
                    0
                  ];
          }
          break;
      case 1 :
          break;
      case 2 :
          if (a[1] === 0) {
            return /* tuple */[
                    2,
                    0
                  ];
          }
          break;
      default:
        
    }
  }
  if (b[0] !== 2) {
    throw [
          LatticeError,
          "not a lattice element"
        ];
  }
  if (b[1] !== 0) {
    throw [
          LatticeError,
          "not a lattice element"
        ];
  } else {
    return /* tuple */[
            2,
            0
          ];
  }
}

function simpleNot(a) {
  switch (a[0]) {
    case 0 :
        if (a[1] !== 0) {
          throw [
                LatticeError,
                "not a lattice element"
              ];
        } else {
          return /* tuple */[
                  0,
                  0
                ];
        }
    case 1 :
        var match = a[1];
        if (match !== 0) {
          if (match !== 1) {
            throw [
                  LatticeError,
                  "not a lattice element"
                ];
          } else {
            return /* tuple */[
                    1,
                    0
                  ];
          }
        } else {
          return /* tuple */[
                  1,
                  1
                ];
        }
    case 2 :
        if (a[1] !== 0) {
          throw [
                LatticeError,
                "not a lattice element"
              ];
        } else {
          return /* tuple */[
                  2,
                  0
                ];
        }
    default:
      throw [
            LatticeError,
            "not a lattice element"
          ];
  }
}

function simpleParse(str) {
  switch (str) {
    case "B" :
        return /* tuple */[
                true,
                /* tuple */[
                  0,
                  0
                ]
              ];
    case "T" :
        return /* tuple */[
                true,
                /* tuple */[
                  2,
                  0
                ]
              ];
    case "f" :
        return /* tuple */[
                true,
                /* tuple */[
                  1,
                  0
                ]
              ];
    case "t" :
        return /* tuple */[
                true,
                /* tuple */[
                  1,
                  1
                ]
              ];
    default:
      return /* tuple */[
              false,
              /* tuple */[
                2,
                0
              ]
            ];
  }
}

var simpleLattice_highValues = /* :: */[
  /* tuple */[
    1,
    1
  ],
  /* [] */0
];

var simpleLattice = {
  elems: simpleLatticeElems,
  highValues: simpleLattice_highValues,
  leq: simpleLeq,
  joinOp: simpleJoin,
  meetOp: simpleMeet,
  andOp: simpleAnd,
  orOp: simpleOr,
  notOp: simpleNot,
  print: printSimpleLattice,
  parse: simpleParse
};

function getLattice(lat) {
  return simpleLatticeElems;
}

var bot = /* tuple */[
  0,
  0
];

var t = /* tuple */[
  1,
  1
];

var f = /* tuple */[
  1,
  0
];

var top = /* tuple */[
  2,
  0
];

export {
  LatticeError ,
  latticeError ,
  simpleLatticeElems ,
  bot ,
  t ,
  f ,
  top ,
  simpleLeq ,
  printSimpleLattice ,
  simpleJoin ,
  simpleMeet ,
  simpleAnd ,
  simpleOr ,
  simpleNot ,
  simpleParse ,
  simpleLattice ,
  getLattice ,
  
}
/* No side effect */
