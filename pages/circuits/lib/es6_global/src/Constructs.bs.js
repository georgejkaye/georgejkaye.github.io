// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as Block from "../../../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Caml_obj from "../../../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Pervasives from "../../../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Circuits$CircuitVisualiser from "./Circuits.bs.js";
import * as Lattices$CircuitVisualiser from "./Lattices.bs.js";

var t = Circuits$CircuitVisualiser.value(Lattices$CircuitVisualiser.simpleLattice, Lattices$CircuitVisualiser.t);

var f = Circuits$CircuitVisualiser.value(Lattices$CircuitVisualiser.simpleLattice, Lattices$CircuitVisualiser.f);

var bot = Circuits$CircuitVisualiser.value(Lattices$CircuitVisualiser.simpleLattice, Lattices$CircuitVisualiser.bot);

var top = Circuits$CircuitVisualiser.value(Lattices$CircuitVisualiser.simpleLattice, Lattices$CircuitVisualiser.top);

function andGate(v) {
  return {
          v: v,
          c: /* Function */Block.__(5, [
              "AND",
              "\\wedge",
              2,
              1,
              (function (c) {
                  var match = c.c;
                  if (match.tag === /* Tensor */3) {
                    var match$1 = match[0];
                    if (match$1) {
                      var a = match$1[0];
                      var match$2 = a.c;
                      if (!match$2.tag) {
                        var match$3 = match$1[1];
                        if (match$3) {
                          var match$4 = match$3[0].c;
                          if (!match$4.tag) {
                            if (match$3[1]) {
                              return Pervasives.failwith("Bad input");
                            } else {
                              return Circuits$CircuitVisualiser.value(v, Curry._2(v.andOp, match$2[0], match$4[0]));
                            }
                          }
                          
                        } else {
                          return Pervasives.failwith("Bad input");
                        }
                      }
                      var match$5 = match$1[1];
                      if (match$5 && !match$5[1]) {
                        var b = match$5[0];
                        return Circuits$CircuitVisualiser.func(v, Circuits$CircuitVisualiser.printCircuit(a) + (" AND " + Circuits$CircuitVisualiser.printCircuit(b)), Circuits$CircuitVisualiser.printCircuitLatex(a) + (" \\wedge " + Circuits$CircuitVisualiser.printCircuit(b)), Circuits$CircuitVisualiser.inputs(a) + Circuits$CircuitVisualiser.inputs(b) | 0, 1, (function (param) {
                                      return Pervasives.failwith("not implemented");
                                    }));
                      } else {
                        return Pervasives.failwith("Bad input");
                      }
                    } else {
                      return Pervasives.failwith("Bad input");
                    }
                  } else {
                    return Pervasives.failwith("Bad input");
                  }
                })
            ]),
          l: /* [] */0
        };
}

function orGate(v) {
  return {
          v: v,
          c: /* Function */Block.__(5, [
              "OR",
              "\\vee",
              2,
              1,
              (function (c) {
                  var match = c.c;
                  if (match.tag === /* Tensor */3) {
                    var match$1 = match[0];
                    if (match$1) {
                      var a = match$1[0];
                      var match$2 = a.c;
                      if (!match$2.tag) {
                        var match$3 = match$1[1];
                        if (match$3) {
                          var match$4 = match$3[0].c;
                          if (!match$4.tag) {
                            if (match$3[1]) {
                              return Pervasives.failwith("Bad input");
                            } else {
                              return Circuits$CircuitVisualiser.value(v, Curry._2(v.orOp, match$2[0], match$4[0]));
                            }
                          }
                          
                        } else {
                          return Pervasives.failwith("Bad input");
                        }
                      }
                      var match$5 = match$1[1];
                      if (match$5 && !match$5[1]) {
                        var b = match$5[0];
                        return Circuits$CircuitVisualiser.func(v, Circuits$CircuitVisualiser.printCircuit(a) + (" OR " + Circuits$CircuitVisualiser.printCircuit(b)), Circuits$CircuitVisualiser.printCircuitLatex(a) + (" \\vee " + Circuits$CircuitVisualiser.printCircuit(b)), Circuits$CircuitVisualiser.inputs(a) + Circuits$CircuitVisualiser.inputs(b) | 0, 1, (function (param) {
                                      return Pervasives.failwith("not implemented");
                                    }));
                      } else {
                        return Pervasives.failwith("Bad input");
                      }
                    } else {
                      return Pervasives.failwith("Bad input");
                    }
                  } else {
                    return Pervasives.failwith("Bad input");
                  }
                })
            ]),
          l: /* [] */0
        };
}

function norGate(v) {
  return {
          v: v,
          c: /* Function */Block.__(5, [
              "NOR",
              "\\downarrow",
              2,
              1,
              (function (c) {
                  var match = c.c;
                  if (match.tag === /* Tensor */3) {
                    var match$1 = match[0];
                    if (match$1) {
                      var a = match$1[0];
                      var match$2 = a.c;
                      if (!match$2.tag) {
                        var match$3 = match$1[1];
                        if (match$3) {
                          var match$4 = match$3[0].c;
                          if (!match$4.tag) {
                            if (match$3[1]) {
                              return Pervasives.failwith("Bad input");
                            } else {
                              return Circuits$CircuitVisualiser.value(v, Curry._1(v.notOp, Curry._2(v.orOp, match$2[0], match$4[0])));
                            }
                          }
                          
                        } else {
                          return Pervasives.failwith("Bad input");
                        }
                      }
                      var match$5 = match$1[1];
                      if (match$5 && !match$5[1]) {
                        var b = match$5[0];
                        return Circuits$CircuitVisualiser.func(v, Circuits$CircuitVisualiser.printCircuit(a) + (" OR " + Circuits$CircuitVisualiser.printCircuit(b)), Circuits$CircuitVisualiser.printCircuitLatex(a) + (" \\downarrow " + Circuits$CircuitVisualiser.printCircuit(b)), Circuits$CircuitVisualiser.inputs(a) + Circuits$CircuitVisualiser.inputs(b) | 0, 1, (function (param) {
                                      return Pervasives.failwith("not implemented");
                                    }));
                      } else {
                        return Pervasives.failwith("Bad input");
                      }
                    } else {
                      return Pervasives.failwith("Bad input");
                    }
                  } else {
                    return Pervasives.failwith("Bad input");
                  }
                })
            ]),
          l: /* [] */0
        };
}

function xorGate(v) {
  return {
          v: v,
          c: /* Function */Block.__(5, [
              "XOR",
              "\\oplus",
              2,
              1,
              (function (c) {
                  var match = c.c;
                  if (match.tag === /* Tensor */3) {
                    var match$1 = match[0];
                    if (match$1) {
                      var a = match$1[0];
                      var match$2 = a.c;
                      if (!match$2.tag) {
                        var match$3 = match$1[1];
                        if (match$3) {
                          var match$4 = match$3[0].c;
                          if (!match$4.tag) {
                            if (match$3[1]) {
                              return Pervasives.failwith("Bad input");
                            } else {
                              var b = match$4[0];
                              var a$1 = match$2[0];
                              return Circuits$CircuitVisualiser.value(v, Curry._2(v.andOp, Curry._1(v.notOp, Curry._2(v.andOp, a$1, b)), Curry._2(v.orOp, a$1, b)));
                            }
                          }
                          
                        } else {
                          return Pervasives.failwith("Bad input");
                        }
                      }
                      var match$5 = match$1[1];
                      if (match$5 && !match$5[1]) {
                        var b$1 = match$5[0];
                        return Circuits$CircuitVisualiser.func(v, Circuits$CircuitVisualiser.printCircuit(a) + (" OR " + Circuits$CircuitVisualiser.printCircuit(b$1)), Circuits$CircuitVisualiser.printCircuitLatex(a) + (" \\vee " + Circuits$CircuitVisualiser.printCircuit(b$1)), Circuits$CircuitVisualiser.inputs(a) + Circuits$CircuitVisualiser.inputs(b$1) | 0, 1, (function (param) {
                                      return Pervasives.failwith("not implemented");
                                    }));
                      } else {
                        return Pervasives.failwith("Bad input");
                      }
                    } else {
                      return Pervasives.failwith("Bad input");
                    }
                  } else {
                    return Pervasives.failwith("Bad input");
                  }
                })
            ]),
          l: /* [] */0
        };
}

function notGate(v) {
  return {
          v: v,
          c: /* Function */Block.__(5, [
              "NOT",
              "\\neg",
              1,
              1,
              (function (c) {
                  var match = c.c;
                  if (match.tag) {
                    return Circuits$CircuitVisualiser.func(v, "\xc2\xac" + Circuits$CircuitVisualiser.printCircuit(c), "\\neg " + Circuits$CircuitVisualiser.printCircuitLatex(c), Circuits$CircuitVisualiser.inputs(c), 1, (function (param) {
                                  return Pervasives.failwith("not implemented");
                                }));
                  } else {
                    return Circuits$CircuitVisualiser.value(v, Curry._1(v.notOp, match[0]));
                  }
                })
            ]),
          l: /* [] */0
        };
}

function id(v, n) {
  return Circuits$CircuitVisualiser.func(v, "id\\{" + (String(n) + "\\}"), "\\text{id}_" + String(n), n, n, (function (c) {
                return c;
              }));
}

function first(v) {
  return Circuits$CircuitVisualiser.func(v, "fst", "\\text{fst}", 2, 1, (function (c) {
                var match = c.c;
                if (match.tag === /* Tensor */3) {
                  var match$1 = match[0];
                  if (match$1) {
                    var match$2 = match$1[1];
                    if (match$2 && !match$2[1]) {
                      return match$1[0];
                    } else {
                      return Pervasives.failwith("Bad input");
                    }
                  } else {
                    return Pervasives.failwith("Bad input");
                  }
                } else {
                  return Pervasives.failwith("Bad input");
                }
              }));
}

function second(v) {
  return Circuits$CircuitVisualiser.func(v, "snd", "\\text{snd}", 2, 1, (function (c) {
                var match = c.c;
                if (match.tag === /* Tensor */3) {
                  var match$1 = match[0];
                  if (match$1) {
                    var match$2 = match$1[1];
                    if (match$2 && !match$2[1]) {
                      return match$2[0];
                    } else {
                      return Pervasives.failwith("Bad input");
                    }
                  } else {
                    return Pervasives.failwith("Bad input");
                  }
                } else {
                  return Pervasives.failwith("Bad input");
                }
              }));
}

function multiplexer(v) {
  return Circuits$CircuitVisualiser.func(v, "m", "\\text{m}", 3, 1, (function (c) {
                var match = c.c;
                if (match.tag === /* Tensor */3) {
                  var match$1 = match[0];
                  if (match$1) {
                    var match$2 = match$1[0].c;
                    if (match$2.tag) {
                      return Pervasives.failwith("Bad input");
                    } else {
                      var match$3 = match$1[1];
                      if (match$3) {
                        var match$4 = match$3[1];
                        if (match$4 && !match$4[1]) {
                          var c$1 = match$2[0];
                          var match$5 = List.exists((function (x) {
                                  return Caml_obj.caml_equal(x, c$1);
                                }), v.highValues);
                          if (match$5) {
                            return match$3[0];
                          } else {
                            return match$4[0];
                          }
                        } else {
                          return Pervasives.failwith("Bad input");
                        }
                      } else {
                        return Pervasives.failwith("Bad input");
                      }
                    }
                  } else {
                    return Pervasives.failwith("Bad input");
                  }
                } else {
                  return Pervasives.failwith("Bad input");
                }
              }));
}

var v = Lattices$CircuitVisualiser.simpleLattice;

export {
  v ,
  t ,
  f ,
  bot ,
  top ,
  andGate ,
  orGate ,
  norGate ,
  xorGate ,
  notGate ,
  id ,
  first ,
  second ,
  multiplexer ,
  
}
/* t Not a pure module */
