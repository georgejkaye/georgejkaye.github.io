// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Curry from "../../../node_modules/bs-platform/lib/es6/curry.js";
import * as React from "react";
import * as CamlinternalOO from "../../../node_modules/bs-platform/lib/es6/camlinternalOO.js";
import * as GraphvizReact from "graphviz-react";
import * as ReactMathjax2 from "react-mathjax2";
import * as Caml_js_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_js_exceptions.js";
import * as Parser$CircuitVisualiser from "./Parser.bs.js";
import * as Drawing$CircuitVisualiser from "./Drawing.bs.js";
import * as Circuits$CircuitVisualiser from "./Circuits.bs.js";
import * as Examples$CircuitVisualiser from "./Examples.bs.js";
import * as Lattices$CircuitVisualiser from "./Lattices.bs.js";
import * as Algebraic$CircuitVisualiser from "./Algebraic.bs.js";
import * as Hypernets$CircuitVisualiser from "./Hypernets.bs.js";

var Graphviz = { };

var MathJaxNode = { };

var MathJaxContext = { };

function Interface$MathJax(Props) {
  var string = Props.string;
  return React.createElement(ReactMathjax2.Context, {
              input: "tex",
              children: React.createElement("div", undefined, React.createElement(ReactMathjax2.Node, {
                        inline: true,
                        children: string
                      }))
            });
}

var MathJax = {
  make: Interface$MathJax
};

function str(prim) {
  return prim;
}

function printLatexOrError(string, error) {
  if (error) {
    return React.createElement(Interface$MathJax, {
                string: string
              });
  } else {
    return string;
  }
}

function generateCircuit(state, text) {
  if (text === "") {
    return /* tuple */[
            true,
            /* tuple */[
              Circuits$CircuitVisualiser.zero(state.lat),
              ""
            ]
          ];
  } else {
    var item;
    try {
      item = Parser$CircuitVisualiser.parseFromString(state.lat, state.funs, state.macs, text);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Parser$CircuitVisualiser.ParseError || exn[0] === Circuits$CircuitVisualiser.SemanticsError) {
        return /* tuple */[
                false,
                /* tuple */[
                  Circuits$CircuitVisualiser.zero(state.lat),
                  exn[1]
                ]
              ];
      } else {
        throw exn;
      }
    }
    return /* tuple */[
            true,
            /* tuple */[
              item,
              Circuits$CircuitVisualiser.printCircuitLatex(item)
            ]
          ];
  }
}

var class_tables = /* Cons */[
  0,
  0,
  0
];

function minimiseHypergraph(state) {
  if (!class_tables[0]) {
    var $$class = CamlinternalOO.create_table(0);
    var env = CamlinternalOO.new_variable($$class, "");
    var env_init = function (env$1) {
      var self = CamlinternalOO.create_object_opt(0, $$class);
      self[env] = env$1;
      return self;
    };
    CamlinternalOO.init_class($$class);
    class_tables[0] = env_init;
  }
  return Curry._1(class_tables[0], 0);
}

function valueFromEvent(evt) {
  return evt.target.value;
}

function Interface$Input(Props) {
  var onSubmit = Props.onSubmit;
  var match = React.useReducer((function (param, newText) {
          return newText;
        }), "");
  var setText = match[1];
  var text = match[0];
  return React.createElement("input", {
              placeholder: "Type in a circuit!",
              type: "text",
              value: text,
              onKeyDown: (function (evt) {
                  if (evt.key === "Enter") {
                    return Curry._1(onSubmit, text);
                  } else {
                    return 0;
                  }
                }),
              onChange: (function (evt) {
                  return Curry._1(setText, evt.target.value);
                })
            });
}

var Input = {
  make: Interface$Input
};

function Interface(Props) {
  var match = React.useReducer((function (state, action) {
          if (action) {
            var text = action[0];
            if (state.old === text) {
              return state;
            } else {
              var generatedCircuit = generateCircuit(state, text);
              var generatedHypernet = Hypernets$CircuitVisualiser.convertCircuitToHypernet(generatedCircuit[1][0]);
              var generatedDot = Drawing$CircuitVisualiser.generateGraphvizCode(generatedHypernet);
              var generatedAlg = Algebraic$CircuitVisualiser.generateAlgebraicDefinition(generatedHypernet);
              var algebraicLatex = Algebraic$CircuitVisualiser.algebraicNetLatex(generatedAlg);
              var formalDot = Drawing$CircuitVisualiser.generateFormalGraphvizCode(generatedAlg);
              return {
                      old: text,
                      lat: state.lat,
                      circ: generatedCircuit[1][0],
                      strn: generatedCircuit[1][1],
                      funs: state.funs,
                      macs: state.macs,
                      net: generatedHypernet,
                      dot: generatedDot,
                      alg: algebraicLatex,
                      form: formalDot,
                      error: generatedCircuit[0]
                    };
            }
          } else {
            var minimisedHypernet = Hypernets$CircuitVisualiser.minimise(state.net);
            var generatedDot$1 = Drawing$CircuitVisualiser.generateGraphvizCode(minimisedHypernet);
            var generatedAlg$1 = Algebraic$CircuitVisualiser.generateAlgebraicDefinition(minimisedHypernet);
            var algebraicLatex$1 = Algebraic$CircuitVisualiser.algebraicNetLatex(generatedAlg$1);
            var formalDot$1 = Drawing$CircuitVisualiser.generateFormalGraphvizCode(generatedAlg$1);
            return {
                    old: "",
                    lat: state.lat,
                    circ: state.circ,
                    strn: state.strn,
                    funs: state.funs,
                    macs: state.macs,
                    net: minimisedHypernet,
                    dot: generatedDot$1,
                    alg: algebraicLatex$1,
                    form: formalDot$1,
                    error: state.error
                  };
          }
        }), {
        old: "",
        lat: Lattices$CircuitVisualiser.simpleLattice,
        circ: Circuits$CircuitVisualiser.zero(Lattices$CircuitVisualiser.simpleLattice),
        strn: "",
        funs: Examples$CircuitVisualiser.exampleFunctions,
        macs: Examples$CircuitVisualiser.exampleMacros,
        net: Hypernets$CircuitVisualiser.zeroNet,
        dot: Drawing$CircuitVisualiser.zeroDot,
        alg: "",
        form: "",
        error: false
      });
  var dispatch = match[1];
  var match$1 = match[0];
  var dot = match$1.dot;
  return React.createElement("div", {
              className: "main"
            }, React.createElement("div", {
                  className: "title"
                }, React.createElement("h1", undefined, "Circuit visualiser ")), React.createElement("div", {
                  className: "input"
                }, React.createElement(Interface$Input, {
                      onSubmit: (function (text) {
                          return Curry._1(dispatch, /* ParseNewCircuit */[text]);
                        })
                    }), React.createElement("button", {
                      onClick: (function (param) {
                          return Curry._1(dispatch, /* MinimiseHypergraph */0);
                        })
                    }, "Minimise")), React.createElement("div", undefined, printLatexOrError(match$1.strn, match$1.error)), React.createElement("table", undefined, React.createElement("tbody", undefined, React.createElement("tr", undefined, React.createElement("td", {
                              width: "500px"
                            }, React.createElement("div", {
                                  className: "instructions"
                                }, React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "a . b"), React.createElement("b", undefined, " Horizontal composition"), " left to right"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "a * b"), React.createElement("b", undefined, " Vertical composition (tensor)")), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "a^n"), React.createElement("b", undefined, " Index"), " Composes multiple copies of a circuit together vertically"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "/\\"), React.createElement("b", undefined, " Fork"), " a bus of width 1 into a bus of width 2"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "\\/"), React.createElement("b", undefined, " Join"), " a bus of width 2 into a bus of width 1"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "/\\{n}"), React.createElement("b", undefined, " Diagonal fork"), " a bus of width n into a bus of width 2n"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "\\/{n}"), React.createElement("b", undefined, " Diagonal join"), " a bus of width 2n into a bus of width n"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "~"), React.createElement("b", undefined, " Stub"), " a bus of width 1"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "x{a,b}"), React.createElement("b", undefined, " Swap"), " buses of width a and b"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "Tr{n}(a)"), React.createElement("b", undefined, " Trace"), " a circuit, using n of its outputs as inputs"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "iter(a)"), React.createElement("b", undefined, " Iterate"), " a circuit, using all of its outputs as inputs"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "\\xy."), " or ", React.createElement("span", {
                                          className: "code"
                                        }, "\\x,y."), React.createElement("b", undefined, " Link"), " outlink x with inlink y"))), React.createElement("td", undefined, React.createElement("div", undefined, React.createElement(Interface$MathJax, {
                                      string: match$1.alg
                                    }))), React.createElement("td", undefined, React.createElement("div", undefined, React.createElement("textarea", {
                                      cols: 100,
                                      readOnly: true,
                                      rows: 15,
                                      value: dot
                                    })))))), React.createElement(GraphvizReact.Graphviz, {
                  dot: dot,
                  options: {
                    fit: true,
                    height: 500,
                    width: 1000
                  }
                }));
}

var make = Interface;

export {
  Graphviz ,
  MathJaxNode ,
  MathJaxContext ,
  MathJax ,
  str ,
  printLatexOrError ,
  generateCircuit ,
  minimiseHypergraph ,
  valueFromEvent ,
  Input ,
  make ,
  
}
/* react Not a pure module */
