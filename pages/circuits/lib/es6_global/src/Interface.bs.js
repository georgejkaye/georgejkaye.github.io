// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Curry from "../../../node_modules/bs-platform/lib/es6/curry.js";
import * as React from "react";
import * as GraphvizReact from "graphviz-react";
import * as ReactMathjax2 from "react-mathjax2";
import * as Caml_js_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_js_exceptions.js";
import * as Parser$CircuitVisualiser from "./Parser.bs.js";
import * as Circuits$CircuitVisualiser from "./Circuits.bs.js";
import * as Examples$CircuitVisualiser from "./Examples.bs.js";
import * as Lattices$CircuitVisualiser from "./Lattices.bs.js";
import * as Hypernets$CircuitVisualiser from "./Hypernets.bs.js";

var Graphviz = { };

var MathJaxNode = { };

var MathJaxContext = { };

function Interface$MathJax(Props) {
  var string = Props.string;
  return React.createElement(ReactMathjax2.Context, {
              input: "tex",
              children: React.createElement("div", undefined, React.createElement(ReactMathjax2.Node, {
                        inline: true,
                        children: string
                      }))
            });
}

var MathJax = {
  make: Interface$MathJax
};

function str(prim) {
  return prim;
}

function generateSVGString(param) {
  return "";
}

function printLatexOrError(string, error) {
  if (error) {
    return React.createElement(Interface$MathJax, {
                string: string
              });
  } else {
    return string;
  }
}

function generateCircuit(state, text) {
  var item;
  try {
    item = Parser$CircuitVisualiser.parseFromString(state.lat, state.funs, state.macs, text);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Parser$CircuitVisualiser.ParseError || exn[0] === Circuits$CircuitVisualiser.SemanticsError) {
      return /* tuple */[
              false,
              /* tuple */[
                Circuits$CircuitVisualiser.zero(state.lat),
                exn[1]
              ]
            ];
    } else {
      throw exn;
    }
  }
  return /* tuple */[
          true,
          /* tuple */[
            item,
            Circuits$CircuitVisualiser.printCircuitLatex(item)
          ]
        ];
}

function valueFromEvent(evt) {
  return evt.target.value;
}

function Interface$Input(Props) {
  var onSubmit = Props.onSubmit;
  var match = React.useReducer((function (param, newText) {
          return newText;
        }), "");
  var setText = match[1];
  var text = match[0];
  return React.createElement("input", {
              placeholder: "Type in a circuit!",
              type: "text",
              value: text,
              onKeyDown: (function (evt) {
                  if (evt.key === "Enter") {
                    return Curry._1(onSubmit, text);
                  } else {
                    return 0;
                  }
                }),
              onChange: (function (evt) {
                  return Curry._1(setText, evt.target.value);
                })
            });
}

var Input = {
  make: Interface$Input
};

function Interface(Props) {
  var match = React.useReducer((function (state, action) {
          var text = action[0];
          if (state.old === text) {
            return state;
          } else {
            var generatedCircuit = generateCircuit(state, text);
            var generatedHypernet = Hypernets$CircuitVisualiser.convertCircuitToHypernet(generatedCircuit[1][0]);
            var generatedDot = Hypernets$CircuitVisualiser.generateGraphvizCode(generatedHypernet);
            console.log(generatedDot);
            return {
                    old: text,
                    lat: state.lat,
                    circ: generatedCircuit[1][0],
                    strn: generatedCircuit[1][1],
                    funs: state.funs,
                    macs: state.macs,
                    net: generatedHypernet,
                    dot: generatedDot,
                    svg: "",
                    error: generatedCircuit[0]
                  };
          }
        }), {
        old: "",
        lat: Lattices$CircuitVisualiser.simpleLattice,
        circ: Circuits$CircuitVisualiser.zero(Lattices$CircuitVisualiser.simpleLattice),
        strn: "",
        funs: Examples$CircuitVisualiser.exampleFunctions,
        macs: Examples$CircuitVisualiser.exampleMacros,
        net: Hypernets$CircuitVisualiser.zeroNet,
        dot: Hypernets$CircuitVisualiser.zeroDot,
        svg: "",
        error: false
      });
  var dispatch = match[1];
  var match$1 = match[0];
  var dot = match$1.dot;
  return React.createElement("div", {
              className: "main"
            }, React.createElement("div", {
                  className: "title"
                }, React.createElement("h1", undefined, "Circuit visualiser ")), React.createElement("div", {
                  className: "input"
                }, React.createElement(Interface$Input, {
                      onSubmit: (function (text) {
                          return Curry._1(dispatch, /* ParseNewCircuit */[text]);
                        })
                    })), React.createElement("div", undefined, printLatexOrError(match$1.strn, match$1.error)), React.createElement("table", undefined, React.createElement("tbody", undefined, React.createElement("tr", undefined, React.createElement("td", undefined, React.createElement("div", {
                                  className: "instructions"
                                }, React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "a . b"), React.createElement("b", undefined, " Horizontal composition"), " left to right"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "a * b"), React.createElement("b", undefined, " Vertical composition (tensor)")), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "a^n"), React.createElement("b", undefined, " Index"), " Composes multiple copies of a circuit together vertically"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "/\\"), React.createElement("b", undefined, " Fork"), " a bus of width 1 into a bus of width 2"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "\\/"), React.createElement("b", undefined, " Join"), " a bus of width 2 into a bus of width 1"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "/\\{n}"), React.createElement("b", undefined, " Diagonal fork"), " a bus of width n into a bus of width 2n"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "\\/{n}"), React.createElement("b", undefined, " Diagonal join"), " a bus of width 2n into a bus of width n"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "~"), React.createElement("b", undefined, " Stub"), " a bus of width 1"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "x{a,b}"), React.createElement("b", undefined, " Swap"), " buses of width a and b"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "Tr{n}(a)"), React.createElement("b", undefined, " Trace"), " a circuit, using n of its outputs as inputs"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "iter(a)"), React.createElement("b", undefined, " Iterate"), " a circuit, using all of its outputs as inputs"), React.createElement("div", undefined, React.createElement("span", {
                                          className: "code"
                                        }, "\\xy."), " or ", React.createElement("span", {
                                          className: "code"
                                        }, "\\x,y."), React.createElement("b", undefined, " Link"), " outlink x with inlink y"))), React.createElement("td", undefined, React.createElement("div", {
                                  className: "right"
                                }, React.createElement("textarea", {
                                      cols: 100,
                                      readOnly: true,
                                      rows: 15,
                                      value: dot
                                    })))))), React.createElement("a", {
                  download: "graph",
                  href: match$1.svg,
                  target: "_blank"
                }, React.createElement(GraphvizReact.Graphviz, {
                      dot: dot,
                      options: {
                        fit: true,
                        height: 1000,
                        width: 1000
                      }
                    })));
}

var make = Interface;

export {
  Graphviz ,
  MathJaxNode ,
  MathJaxContext ,
  MathJax ,
  str ,
  generateSVGString ,
  printLatexOrError ,
  generateCircuit ,
  valueFromEvent ,
  Input ,
  make ,
  
}
/* react Not a pure module */
