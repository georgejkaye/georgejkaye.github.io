// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as Curry from "../../../node_modules/bs-platform/lib/es6/curry.js";
import * as $$String from "../../../node_modules/bs-platform/lib/es6/string.js";
import * as Caml_array from "../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Pervasives from "../../../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Caml_string from "../../../node_modules/bs-platform/lib/es6/caml_string.js";

function assert$prime(condition, error, message) {
  if (condition) {
    return /* () */0;
  } else {
    return Curry._1(error, message);
  }
}

function generateUnicodeSubscript(n) {
  var s1 = String(n);
  var s2 = "";
  for(var i = 0 ,i_finish = s1.length - 1 | 0; i <= i_finish; ++i){
    s2 = s2 + ("&#832" + ($$String.make(1, Caml_string.get(s1, i)) + ";"));
  }
  return s2;
}

function swap(a, b) {
  return /* tuple */[
          b,
          a
        ];
}

function t1(a, param, param$1) {
  return a;
}

function t2(param, b, param$1) {
  return b;
}

function t3(param, param$1, c) {
  return c;
}

function split$prime(_n, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var n = _n;
    if (ys) {
      var yss = ys[1];
      var y = ys[0];
      var match = n === 0;
      if (match) {
        return /* tuple */[
                xs,
                /* :: */[
                  y,
                  yss
                ]
              ];
      } else {
        _ys = yss;
        _xs = List.concat(/* :: */[
              xs,
              /* :: */[
                /* :: */[
                  y,
                  /* [] */0
                ],
                /* [] */0
              ]
            ]);
        _n = n - 1 | 0;
        continue ;
      }
    } else {
      return /* tuple */[
              xs,
              /* [] */0
            ];
    }
  };
}

function split(n, xs) {
  return split$prime(n, /* [] */0, xs);
}

function printList$prime(xs, print) {
  if (xs) {
    var x = xs[0];
    var match = Curry._1(print, x) === "";
    var elem = match ? "_" : Curry._1(print, x);
    return elem + (" :: " + printList$prime(xs[1], print));
  } else {
    return "";
  }
}

function printList(xs, print) {
  var string = printList$prime(xs, print);
  var match = string === "";
  if (match) {
    return "[]";
  } else {
    return "[ " + ($$String.sub(string, 0, string.length - 1 | 0) + " ]");
  }
}

function printListCommas$prime(xs, print) {
  if (xs) {
    var x = xs[0];
    var match = Curry._1(print, x) === "";
    var elem = match ? "_" : Curry._1(print, x);
    return elem + (", " + printListCommas$prime(xs[1], print));
  } else {
    return "";
  }
}

function printListCommas(xs, print) {
  var string = printListCommas$prime(xs, print);
  var match = string === "";
  if (match) {
    return "";
  } else {
    return $$String.sub(string, 0, string.length - 2 | 0);
  }
}

function printStringList(xs) {
  return printList(xs, (function (x) {
                return x;
              }));
}

function printIntList(xs) {
  return printList(xs, (function (x) {
                return String(x);
              }));
}

function printCharList(xs) {
  return printList(xs, (function (x) {
                return $$String.make(1, x);
              }));
}

function range$prime(n) {
  if (n !== 0) {
    return /* :: */[
            n,
            range$prime(n - 1 | 0)
          ];
  } else {
    return /* :: */[
            0,
            /* [] */0
          ];
  }
}

function range(n) {
  return List.rev(range$prime(n));
}

function addToEnd(n, xs) {
  return List.concat(/* :: */[
              xs,
              /* :: */[
                /* :: */[
                  n,
                  /* [] */0
                ],
                /* [] */0
              ]
            ]);
}

function slice$prime(_xs, a, b, _n) {
  while(true) {
    var n = _n;
    var xs = _xs;
    if (xs) {
      var xs$1 = xs[1];
      var x = xs[0];
      var match = n < a;
      if (match) {
        _n = n + 1 | 0;
        _xs = xs$1;
        continue ;
      } else {
        var match$1 = n < b;
        if (match$1) {
          return /* :: */[
                  x,
                  slice$prime(xs$1, a, b, n + 1 | 0)
                ];
        } else {
          return /* :: */[
                  x,
                  /* [] */0
                ];
        }
      }
    } else {
      return Pervasives.failwith("not enough list!");
    }
  };
}

function slice(xs, a, b) {
  return slice$prime(xs, a, b, 0);
}

function drop$prime(xs, b, n) {
  if (xs) {
    var match = n === b;
    if (match) {
      return /* [] */0;
    } else {
      return /* :: */[
              xs[0],
              drop$prime(xs[1], b, n + 1 | 0)
            ];
    }
  } else {
    return Pervasives.failwith("not enough list!");
  }
}

function drop(xs, b) {
  return drop$prime(xs, List.length(xs) - b | 0, 0);
}

function trim$prime(_xs, b, _n) {
  while(true) {
    var n = _n;
    var xs = _xs;
    if (xs) {
      var xs$1 = xs[1];
      var match = n === b;
      if (match) {
        return xs$1;
      } else {
        _n = n + 1 | 0;
        _xs = xs$1;
        continue ;
      }
    } else {
      return Pervasives.failwith("not enough list!");
    }
  };
}

function trim(xs, b) {
  return trim$prime(xs, b - 1 | 0, 0);
}

function printArray(a, f) {
  var string = "{";
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    string = string + (", " + Curry._1(f, Caml_array.caml_array_get(a, i)));
  }
  return string + "}";
}

export {
  assert$prime ,
  generateUnicodeSubscript ,
  swap ,
  t1 ,
  t2 ,
  t3 ,
  split$prime ,
  split ,
  printList ,
  printList$prime ,
  printListCommas ,
  printListCommas$prime ,
  printStringList ,
  printIntList ,
  printCharList ,
  range ,
  range$prime ,
  addToEnd ,
  slice ,
  slice$prime ,
  drop ,
  drop$prime ,
  trim ,
  trim$prime ,
  printArray ,
  
}
/* No side effect */
