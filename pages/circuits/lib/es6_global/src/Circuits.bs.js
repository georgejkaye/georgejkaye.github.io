// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as Block from "../../../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Caml_obj from "../../../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Pervasives from "../../../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Caml_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_exceptions.js";
import * as Helpers$CircuitVisualiser from "./Helpers.bs.js";

var SemanticsError = Caml_exceptions.create("Circuits-CircuitVisualiser.SemanticsError");

function semanticsError(message) {
  throw [
        SemanticsError,
        message
      ];
}

function lookupLink(i, _l) {
  while(true) {
    var l = _l;
    if (l) {
      var l$1 = l[0];
      var match = Caml_obj.caml_equal(l$1[0][1], i);
      if (match) {
        return l$1[0][0];
      } else {
        var match$1 = Caml_obj.caml_equal(l$1[1][1], i);
        if (match$1) {
          return l$1[1][0];
        } else {
          _l = l[1];
          continue ;
        }
      }
    } else {
      return Pervasives.failwith("Link does not exist, maybe you should be using the option version?");
    }
  };
}

function doesLinkNumberExist(i, _l) {
  while(true) {
    var l = _l;
    if (l) {
      var l$1 = l[0];
      var match = Caml_obj.caml_equal(l$1[0][1], i);
      if (match) {
        return true;
      } else {
        var match$1 = Caml_obj.caml_equal(l$1[1][1], i);
        if (match$1) {
          return true;
        } else {
          _l = l[1];
          continue ;
        }
      }
    } else {
      return false;
    }
  };
}

function doesLinkStringExist(i, _l) {
  while(true) {
    var l = _l;
    if (l) {
      var l$1 = l[0];
      var match = Caml_obj.caml_equal(l$1[0][0], i);
      if (match) {
        return true;
      } else {
        var match$1 = Caml_obj.caml_equal(l$1[1][0], i);
        if (match$1) {
          return true;
        } else {
          _l = l[1];
          continue ;
        }
      }
    } else {
      return false;
    }
  };
}

function printComponent$prime(v, c, l, i) {
  switch (c.tag | 0) {
    case /* Value */0 :
        return Curry._1(v.print, c[0]);
    case /* Composition */2 :
        var b = printCircuit$prime(c[0], 0) + (" ⋅ " + printCircuit$prime(c[1], 0));
        var match = i === 0;
        if (match) {
          return b;
        } else {
          return "(" + (b + ")");
        }
    case /* Tensor */3 :
        var match$1 = c[0];
        if (match$1) {
          var tl = match$1[1];
          var x = match$1[0];
          if (tl) {
            return List.fold_left((function (string, f$prime) {
                          return string + (" ⊗ " + printCircuit$prime(f$prime, i + 1 | 0));
                        }), printCircuit$prime(x, i + 1 | 0), tl);
          } else {
            return printCircuit$prime(x, i + 1 | 0);
          }
        } else {
          return "";
        }
    case /* Swap */4 :
        return "×{" + (String(c[0]) + (", " + String(c[1])));
    case /* Delay */6 :
        return "ẟ{" + (String(c[0]) + "}");
    case /* Trace */7 :
        return "Tr{" + (String(c[0]) + ("}(" + (printCircuit$prime(c[1], 0) + ")")));
    case /* Iter */8 :
        return "iter{" + (String(c[0]) + ("}(" + (printCircuit$prime(c[1], 0) + ")")));
    case /* Link */11 :
        return "\\" + (lookupLink(c[0], l) + ("," + (lookupLink(c[1], l) + (". " + printCircuit$prime(c[2], i)))));
    case /* Function */5 :
    case /* Macro */12 :
        return c[0];
    default:
      return String(c[0]);
  }
}

function printCircuit$prime(param, i) {
  return printComponent$prime(param.v, param.c, param.l, i);
}

function printComponent(v, c, l) {
  return printComponent$prime(v, c, l, 0);
}

function printCircuit(c) {
  return printCircuit$prime(c, 0);
}

function printComponentLatex$prime(v, c, l, i) {
  switch (c.tag | 0) {
    case /* Value */0 :
        return "\\text{" + (Curry._1(v.print, c[0]) + "}");
    case /* Identity */1 :
        return String(c[0]);
    case /* Composition */2 :
        var b = printCircuitLatex$prime(c[0], 0) + (" \\cdot " + printCircuitLatex$prime(c[1], 0));
        var match = i === 0;
        if (match) {
          return b;
        } else {
          return "(" + (b + ")");
        }
    case /* Tensor */3 :
        var match$1 = c[0];
        if (match$1) {
          var tl = match$1[1];
          var x = match$1[0];
          if (tl) {
            return List.fold_left((function (string, f$prime) {
                          return string + (" \\otimes " + printCircuitLatex$prime(f$prime, i + 1 | 0));
                        }), printCircuitLatex$prime(x, i + 1 | 0), tl);
          } else {
            return printCircuitLatex$prime(x, i + 1 | 0);
          }
        } else {
          return "";
        }
    case /* Swap */4 :
        return "\\times_{" + (String(c[0]) + (", " + (String(c[1]) + "}")));
    case /* Delay */6 :
        return "\\delta_" + String(c[0]);
    case /* Trace */7 :
        return "\\text{Tr}^" + (String(c[0]) + ("(" + (printCircuitLatex$prime(c[1], 0) + ")")));
    case /* Iter */8 :
        return "\\text{iter}^" + (String(c[0]) + ("(" + (printCircuitLatex$prime(c[1], 0) + ")")));
    case /* Inlink */9 :
    case /* Outlink */10 :
        return lookupLink(c[0], l);
    case /* Link */11 :
        return "\\overline{" + (lookupLink(c[0], l) + ("\\to " + (lookupLink(c[1], l) + ("}." + printCircuitLatex$prime(c[2], i)))));
    case /* Function */5 :
    case /* Macro */12 :
        return c[1];
    
  }
}

function printCircuitLatex$prime(param, i) {
  return printComponentLatex$prime(param.v, param.c, param.l, i);
}

function printComponentLatex(v, c, l) {
  return printComponentLatex$prime(v, c, l, 0);
}

function printCircuitLatex(c) {
  return printCircuitLatex$prime(c, 0);
}

function printComponentList(v, l, xs) {
  return Helpers$CircuitVisualiser.printList(xs, (function (x) {
                return printComponent(v, x, l);
              }));
}

function printComponentListLatex(v, l, xs) {
  return Helpers$CircuitVisualiser.printList(xs, (function (x) {
                return printComponentLatex(v, x, l);
              }));
}

function printComponentListCommas(v, l, xs) {
  return Helpers$CircuitVisualiser.printListCommas(xs, (function (x) {
                return printComponent(v, x, l);
              }));
}

function printComponentListLatexCommas(v, l, xs) {
  return Helpers$CircuitVisualiser.printListCommas(xs, (function (x) {
                return printComponentLatex(v, x, l);
              }));
}

function printCircuitListCommas(xs) {
  return Helpers$CircuitVisualiser.printListCommas(xs, (function (x) {
                return printCircuit$prime(x, 0);
              }));
}

function printCircuitListLatexCommas(xs) {
  return Helpers$CircuitVisualiser.printListCommas(xs, (function (x) {
                return printCircuitLatex$prime(x, 0);
              }));
}

function inputs$prime(c) {
  switch (c.tag | 0) {
    case /* Identity */1 :
        return c[0];
    case /* Composition */2 :
        return inputs(c[0]);
    case /* Tensor */3 :
        return List.fold_left((function (no, f) {
                      return no + inputs(f) | 0;
                    }), 0, c[0]);
    case /* Swap */4 :
        return c[0] + c[1] | 0;
    case /* Function */5 :
        return c[2];
    case /* Trace */7 :
    case /* Iter */8 :
        return inputs(c[1]) - c[0] | 0;
    case /* Value */0 :
    case /* Inlink */9 :
        return 0;
    case /* Delay */6 :
    case /* Outlink */10 :
        return 1;
    case /* Link */11 :
    case /* Macro */12 :
        return inputs(c[2]);
    
  }
}

function inputs(param) {
  return inputs$prime(param.c);
}

function outputs$prime(c) {
  switch (c.tag | 0) {
    case /* Identity */1 :
        return c[0];
    case /* Tensor */3 :
        return List.fold_left((function (no, f) {
                      return no + outputs(f) | 0;
                    }), 0, c[0]);
    case /* Swap */4 :
        return c[0] + c[1] | 0;
    case /* Function */5 :
        return c[3];
    case /* Trace */7 :
        return outputs(c[1]) - c[0] | 0;
    case /* Composition */2 :
    case /* Iter */8 :
        return outputs(c[1]);
    case /* Outlink */10 :
        return 0;
    case /* Link */11 :
    case /* Macro */12 :
        return outputs(c[2]);
    default:
      return 1;
  }
}

function outputs(param) {
  return outputs$prime(param.c);
}

function circ(v, c, l) {
  return {
          v: v,
          c: c,
          l: l
        };
}

function zero(v) {
  return {
          v: v,
          c: /* Identity */Block.__(1, [0]),
          l: /* [] */0
        };
}

function value(v, x) {
  return {
          v: v,
          c: /* Value */Block.__(0, [x]),
          l: /* [] */0
        };
}

function idcirc(v, n) {
  return {
          v: v,
          c: /* Identity */Block.__(1, [n]),
          l: /* [] */0
        };
}

function compose(c, c$prime) {
  Helpers$CircuitVisualiser.assert$prime(Caml_obj.caml_equal(c.v, c$prime.v), semanticsError, "Circuits use different lattices!");
  Helpers$CircuitVisualiser.assert$prime(outputs(c) === inputs(c$prime), semanticsError, "Outputs of circuit " + (printCircuit$prime(c, 0) + (" do not match inputs of circuit " + printCircuit$prime(c$prime, 0))));
  return {
          v: c.v,
          c: /* Composition */Block.__(2, [
              c,
              c$prime
            ]),
          l: Pervasives.$at(c.l, c$prime.l)
        };
}

function tensor(xs) {
  Helpers$CircuitVisualiser.assert$prime(List.fold_left((function (x, y) {
              if (x) {
                return Caml_obj.caml_equal(y.v, List.hd(xs).v);
              } else {
                return false;
              }
            }), true, xs), semanticsError, "Not all circuits use the same lattice!");
  return {
          v: List.hd(xs).v,
          c: /* Tensor */Block.__(3, [xs]),
          l: List.fold_left((function (x, y) {
                  return Pervasives.$at(x, y.l);
                }), /* [] */0, xs)
        };
}

function func(v, id, latex, ins, outs, f) {
  return {
          v: v,
          c: /* Function */Block.__(5, [
              id,
              latex,
              ins,
              outs,
              f
            ]),
          l: /* [] */0
        };
}

function findLink(x, out, _c) {
  while(true) {
    var c = _c;
    console.log("searching for " + (String(x) + (" in " + printCircuit$prime(c, 0))));
    var match = c.c;
    switch (match.tag | 0) {
      case /* Composition */2 :
          if (findLink(x, out, match[0])) {
            return true;
          } else {
            _c = match[1];
            continue ;
          }
      case /* Tensor */3 :
          return List.fold_left((function (f, g) {
                        if (findLink(x, out, g)) {
                          return true;
                        } else {
                          return f;
                        }
                      }), false, match[0]);
      case /* Trace */7 :
      case /* Iter */8 :
          _c = match[1];
          continue ;
      case /* Inlink */9 :
          var match$1 = x === match[0];
          if (match$1 && !out) {
            return true;
          } else {
            return false;
          }
      case /* Outlink */10 :
          var match$2 = x === match[0];
          if (match$2 && out) {
            return true;
          } else {
            return false;
          }
      case /* Link */11 :
      case /* Macro */12 :
          _c = match[2];
          continue ;
      default:
        return false;
    }
  };
}

function link(v, oux, inx, f, l) {
  if (findLink(oux, true, f)) {
    if (findLink(inx, false, f)) {
      return {
              v: v,
              c: /* Link */Block.__(11, [
                  oux,
                  inx,
                  f
                ]),
              l: l
            };
    } else {
      var ins = lookupLink(inx, l);
      throw [
            SemanticsError,
            "Link " + (ins + " does not exist in circuit")
          ];
    }
  } else {
    var outs = lookupLink(oux, l);
    throw [
          SemanticsError,
          "Link " + (outs + " does not exist in circuit")
        ];
  }
}

function macro(v, id, latex, f, l) {
  return {
          v: v,
          c: /* Macro */Block.__(12, [
              id,
              latex,
              f
            ]),
          l: l
        };
}

function composemany(xs) {
  Helpers$CircuitVisualiser.assert$prime(List.fold_left((function (x, y) {
              if (x) {
                return Caml_obj.caml_equal(y.v, List.hd(xs).v);
              } else {
                return false;
              }
            }), true, xs), semanticsError, "Not all circuits use the same lattice!");
  if (xs) {
    var xs$1 = xs[1];
    var x = xs[0];
    if (xs$1) {
      return compose(x, composemany(xs$1));
    } else {
      return x;
    }
  } else {
    return Pervasives.failwith("no args");
  }
}

function exp$prime(f, x) {
  if (x === 0) {
    return /* [] */0;
  } else {
    return /* :: */[
            f,
            exp$prime(f, x - 1 | 0)
          ];
  }
}

function exp(f, x) {
  return tensor(exp$prime(f, x));
}

function funcBlackBox(v, id, latex, ins, outs) {
  var bb = [];
  Caml_obj.caml_update_dummy(bb, /* Function */Block.__(5, [
          id,
          latex,
          ins,
          outs,
          (function (c) {
              var match = c.c;
              var id$prime;
              if (match.tag === /* Tensor */3) {
                var xs = match[0];
                id$prime = /* tuple */[
                  Helpers$CircuitVisualiser.printListCommas(xs, (function (x) {
                          return printCircuit$prime(x, 0);
                        })),
                  Helpers$CircuitVisualiser.printListCommas(xs, (function (x) {
                          return printCircuit$prime(x, 0);
                        }))
                ];
              } else {
                id$prime = /* tuple */[
                  printCircuit$prime(c, 0),
                  printCircuitLatex$prime(c, 0)
                ];
              }
              return {
                      v: c.v,
                      c: /* Function */Block.__(5, [
                          id + ("(" + (id$prime[0] + ")")),
                          latex + ("(" + (id$prime[1] + ")")),
                          inputs(c),
                          outs,
                          (function (c) {
                              return composemany(/* :: */[
                                          c,
                                          /* :: */[
                                            {
                                              v: v,
                                              c: bb,
                                              l: c.l
                                            },
                                            /* [] */0
                                          ]
                                        ]);
                            })
                        ]),
                      l: c.l
                    };
            })
        ]));
  return {
          v: v,
          c: bb,
          l: /* [] */0
        };
}

function fork(v) {
  return func(v, "⋏", "\\curlywedge", 1, 2, (function (c) {
                return {
                        v: c.v,
                        c: /* Tensor */Block.__(3, [/* :: */[
                              c,
                              /* :: */[
                                c,
                                /* [] */0
                              ]
                            ]]),
                        l: c.l
                      };
              }));
}

function join(v) {
  return func(v, "⋎", "\\curlyvee", 2, 1, (function (c) {
                var match = c.c;
                if (match.tag === /* Tensor */3) {
                  var match$1 = match[0];
                  if (match$1) {
                    var x = match$1[0];
                    var match$2 = x.c;
                    if (!match$2.tag) {
                      var match$3 = match$1[1];
                      if (match$3) {
                        var match$4 = match$3[0].c;
                        if (!match$4.tag) {
                          if (match$3[1]) {
                            return Pervasives.failwith("Join can only take two arguments");
                          } else {
                            return {
                                    v: c.v,
                                    c: /* Value */Block.__(0, [Curry._2(v.joinOp, match$2[0], match$4[0])]),
                                    l: c.l
                                  };
                          }
                        }
                        
                      } else {
                        return Pervasives.failwith("Join can only take two arguments");
                      }
                    }
                    var match$5 = match$1[1];
                    if (match$5 && !match$5[1]) {
                      var y = match$5[0];
                      var newfun_000 = printCircuit$prime(x, 0) + (" ⊔ " + printCircuit$prime(y, 0));
                      var newfun_001 = printCircuitLatex$prime(x, 0) + (" \\sqcup " + printCircuitLatex$prime(y, 0));
                      var newfun_002 = inputs(c);
                      var newfun_004 = function (c) {
                        return compose(c, join(v));
                      };
                      var newfun = /* Function */Block.__(5, [
                          newfun_000,
                          newfun_001,
                          newfun_002,
                          1,
                          newfun_004
                        ]);
                      return {
                              v: c.v,
                              c: newfun,
                              l: c.l
                            };
                    } else {
                      return Pervasives.failwith("Join can only take two arguments");
                    }
                  } else {
                    return Pervasives.failwith("Join can only take two arguments");
                  }
                } else {
                  return Pervasives.failwith("Join can only take two arguments");
                }
              }));
}

function stub(v) {
  return func(v, "~", "{\\sim}", 1, 0, (function (param) {
                return {
                        v: v,
                        c: /* Identity */Block.__(1, [0]),
                        l: /* [] */0
                      };
              }));
}

function specialMorphisms(v) {
  return /* :: */[
          fork(v),
          /* :: */[
            join(v),
            /* :: */[
              stub(v),
              /* [] */0
            ]
          ]
        ];
}

function swap(v, x, y) {
  return {
          v: v,
          c: /* Swap */Block.__(4, [
              x,
              y
            ]),
          l: /* [] */0
        };
}

function dfork(v, n) {
  var comp = n !== 0 ? (
      n !== 1 ? composemany(/* :: */[
              tensor(/* :: */[
                    dfork(v, n - 1 | 0),
                    /* :: */[
                      fork(v),
                      /* [] */0
                    ]
                  ]),
              /* :: */[
                tensor(/* :: */[
                      idcirc(v, n - 1 | 0),
                      /* :: */[
                        swap(v, n - 1 | 0, 1),
                        /* :: */[
                          idcirc(v, 1),
                          /* [] */0
                        ]
                      ]
                    ]),
                /* [] */0
              ]
            ]).c : fork(v).c
    ) : /* Identity */Block.__(1, [0]);
  return macro(v, "Δ{" + (String(n) + "}"), "\\Delta_" + String(n), {
              v: v,
              c: comp,
              l: /* [] */0
            }, /* [] */0);
}

function djoin(v, n) {
  var comp = n !== 0 ? (
      n !== 1 ? composemany(/* :: */[
              tensor(/* :: */[
                    idcirc(v, n - 1 | 0),
                    /* :: */[
                      swap(v, 1, n - 1 | 0),
                      /* :: */[
                        idcirc(v, 1),
                        /* [] */0
                      ]
                    ]
                  ]),
              /* :: */[
                tensor(/* :: */[
                      djoin(v, n - 1 | 0),
                      /* :: */[
                        join(v),
                        /* [] */0
                      ]
                    ]),
                /* [] */0
              ]
            ]).c : join(v).c
    ) : /* Identity */Block.__(1, [0]);
  return macro(v, "∇{" + (String(n) + "}"), "\\nabla_" + String(n), {
              v: v,
              c: comp,
              l: /* [] */0
            }, /* [] */0);
}

function delay(v, n) {
  return {
          v: v,
          c: /* Delay */Block.__(6, [n]),
          l: /* [] */0
        };
}

function trace(x, f) {
  Helpers$CircuitVisualiser.assert$prime(inputs(f) >= x && outputs(f) >= x, semanticsError, "Inputs and outputs of circuit " + (printCircuit$prime(f, 0) + " are less than the size of the trace."));
  return {
          v: f.v,
          c: /* Trace */Block.__(7, [
              x,
              f
            ]),
          l: f.l
        };
}

function iter(f) {
  Helpers$CircuitVisualiser.assert$prime(inputs(f) >= outputs(f), semanticsError, "Not enough inputs of circuit " + (printCircuit$prime(f, 0) + " to iterate."));
  return {
          v: f.v,
          c: /* Iter */Block.__(8, [
              outputs(f),
              f
            ]),
          l: f.l
        };
}

var exponentialSoloRegEx = (/\^([0-9]+)/);

var exponentialRegEx = (/(.+)?\^([0-9]+)/);

var delayRegEx = (/o\{([0-9]+)\}/);

var djoinRegEx = (/\\\/\{([0-9]+)\}/);

var swapRegEx = (/x\{([0-9]+),([0-9]+)\}/);

var dforkRegEx = (/\/\\{([0-9]+)\}/);

var traceRegEx = (/Tr\{([0-9]+)\}/);

var iterRegEx = (/iter\{([0-9]+)\}/);

var iterRegEx2 = (/iter/);

var linkIntroRegEx = (/\\([a-z]+),([a-z]+)\./);

var linkIntroRegEx2 = (/\\([a-z])([a-z])\./);

var constructRegExes_001 = /* :: */[
  dforkRegEx,
  /* :: */[
    djoinRegEx,
    /* :: */[
      delayRegEx,
      /* :: */[
        traceRegEx,
        /* :: */[
          iterRegEx,
          /* :: */[
            iterRegEx2,
            /* :: */[
              exponentialSoloRegEx,
              /* :: */[
                linkIntroRegEx,
                /* :: */[
                  linkIntroRegEx2,
                  /* [] */0
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
];

var constructRegExes = /* :: */[
  swapRegEx,
  constructRegExes_001
];

export {
  SemanticsError ,
  semanticsError ,
  lookupLink ,
  doesLinkNumberExist ,
  doesLinkStringExist ,
  printComponent$prime ,
  printComponent ,
  printCircuit$prime ,
  printCircuit ,
  printComponentLatex$prime ,
  printComponentLatex ,
  printCircuitLatex$prime ,
  printCircuitLatex ,
  printComponentList ,
  printComponentListLatex ,
  printComponentListCommas ,
  printComponentListLatexCommas ,
  printCircuitListCommas ,
  printCircuitListLatexCommas ,
  inputs$prime ,
  inputs ,
  outputs$prime ,
  outputs ,
  circ ,
  zero ,
  value ,
  idcirc ,
  compose ,
  tensor ,
  func ,
  findLink ,
  link ,
  macro ,
  composemany ,
  exp$prime ,
  exp ,
  funcBlackBox ,
  fork ,
  join ,
  stub ,
  specialMorphisms ,
  swap ,
  dfork ,
  djoin ,
  delay ,
  trace ,
  iter ,
  exponentialSoloRegEx ,
  exponentialRegEx ,
  delayRegEx ,
  djoinRegEx ,
  swapRegEx ,
  dforkRegEx ,
  traceRegEx ,
  iterRegEx ,
  iterRegEx2 ,
  linkIntroRegEx ,
  linkIntroRegEx2 ,
  constructRegExes ,
  
}
/* exponentialSoloRegEx Not a pure module */
