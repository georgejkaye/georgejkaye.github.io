// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as Caml_array from "../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Pervasives from "../../../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Hypernets$CircuitVisualiser from "./Hypernets.bs.js";

var arrow = "→";

var tab = "    ";

var nl = "\n";

var graphOptions = "    rankdir=LR;\n    ranksep=0.5;\n    nodesep=0.5;\n";

var vertexOptions = "[style=filled, shape=circle, fillcolor=black; fixedsize=true; width=0.1; label=\"\"];";

var outputWireOptions = "[arrowhead=vee; arrowsize=0.5]";

var inputWireOptions = "[arrowhead=none; arrowsize=0.5]";

var invisibleWireOptions = "[style=invis]";

function formalInputVertexOptions(iv, ov) {
  return "[arrowhead=vee; arrowsize=0.5; headlabel=\"" + (String(iv) + (arrow + (String(ov) + "\"; labeldistance=3; labelangle=180]")));
}

function formalOutputVertexOptions(ov) {
  return "[arrowhead=vee; arrowsize=0.5; taillabel=\"" + (String(ov) + "\"; labeldistance=2; labelangle=180]");
}

function getTraceText(x, e, left) {
  var dir = left ? "l" : "r";
  var name = "trace" + (dir + (String(x) + ("to" + String(e.contents.id))));
  return /* tuple */[
          name,
          name + "[shape=point, width=0.01]\n"
        ];
}

function makeTransitionToAllEdgesWithNoSources(inid, edges) {
  if (edges) {
    var x = edges[0];
    var match = x.sources.length === 0;
    var result = match ? tab + ("e" + (String(inid) + ("->e" + (String(x.id) + " [style=invis]\n")))) : "";
    return result + makeTransitionToAllEdgesWithNoSources(inid, edges[1]);
  } else {
    return "";
  }
}

function makeTransitionToAllEdgesWithNoTargets(outid, edges) {
  if (edges) {
    var x = edges[0];
    var match = x.targets.length === 0;
    var result = match ? tab + ("e" + (String(x.id) + ("->e" + (String(outid) + " [style=invis]\n")))) : "";
    return result + makeTransitionToAllEdgesWithNoTargets(outid, edges[1]);
  } else {
    return "";
  }
}

function generateGraphvizCodeEdge(edge, inid, outid) {
  var ins = edge.sources.length;
  var outs = edge.targets.length;
  var inports = generatePorts(ins, false);
  var outports = generatePorts(outs, true);
  var transitionsdata = generateTransitions(edge.id, inid, outid, edge.targets);
  var match = inports === "{}";
  var instring = match ? "" : inports + " | ";
  var match$1 = outports === "{}";
  var outstring = match$1 ? "" : " | " + outports;
  return /* tuple */[
          tab + ("e" + (String(edge.id) + (" [shape=Mrecord; label=\"{" + (instring + (edge.label + (outstring + "}\"]")))))),
          transitionsdata
        ];
}

function generateGraphvizCodeEdges(inputs, outputs, _es, _ranks, _edges, _traces, _vertices, _inputWires, _outputWires, _traceWires) {
  while(true) {
    var traceWires = _traceWires;
    var outputWires = _outputWires;
    var inputWires = _inputWires;
    var vertices = _vertices;
    var traces = _traces;
    var edges = _edges;
    var ranks = _ranks;
    var es = _es;
    var inid = inputs.contents.id;
    var outid = outputs.contents.id;
    if (es) {
      var edgecode = generateGraphvizCodeEdge(es[0], inid, outid);
      var match = edgecode[0] === "";
      var edgedot = match ? "" : edgecode[0] + ";\n";
      var ranksdot = Caml_array.caml_array_get(edgecode[1], 0);
      var tracedot = Caml_array.caml_array_get(edgecode[1], 1);
      var vertexDot = Caml_array.caml_array_get(edgecode[1], 2);
      var inputWireDot = Caml_array.caml_array_get(edgecode[1], 3);
      var outputWireDot = Caml_array.caml_array_get(edgecode[1], 4);
      var traceWireDot = Caml_array.caml_array_get(edgecode[1], 5);
      _traceWires = traceWires + traceWireDot;
      _outputWires = outputWires + outputWireDot;
      _inputWires = inputWires + inputWireDot;
      _vertices = vertices + vertexDot;
      _traces = traces + tracedot;
      _edges = edges + edgedot;
      _ranks = ranks + ranksdot;
      _es = es[1];
      continue ;
    } else {
      var finalString = "";
      var match$1 = ranks === "";
      if (!match$1) {
        finalString = finalString + ranks;
      }
      var match$2 = edges === "";
      if (!match$2) {
        finalString = finalString + (nl + edges);
      }
      var match$3 = vertices === "";
      if (!match$3) {
        finalString = finalString + (nl + vertices);
      }
      var match$4 = traces === "";
      if (!match$4) {
        finalString = finalString + (nl + traces);
      }
      var match$5 = inputWires === "";
      if (!match$5) {
        finalString = finalString + (nl + inputWires);
      }
      var match$6 = outputWires === "";
      if (!match$6) {
        finalString = finalString + (nl + outputWires);
      }
      var match$7 = traceWires === "";
      if (!match$7) {
        finalString = finalString + (nl + traceWires);
      }
      return finalString;
    }
  };
}

function generatePorts$prime(x, n, out) {
  var y = out ? "t" : "s";
  if (n !== 0) {
    if (n !== 1) {
      return "<" + (y + (String(x) + ("> " + ("•" + (" | " + generatePorts$prime(x + 1 | 0, n - 1 | 0, out))))));
    } else {
      return "<" + (y + (String(x) + ("> " + "•")));
    }
  } else {
    return "";
  }
}

function generateTransitions(x, inid, outid, targets) {
  var vertexString = "";
  var inputWireString = "";
  var outputWireString = "";
  var traceVertexString = "";
  var traceWireString = "";
  var ranks = "";
  for(var i = 0 ,i_finish = targets.length - 1 | 0; i <= i_finish; ++i){
    var match = Caml_array.caml_array_get(targets, i);
    var k = match[1];
    var e = match[0];
    var vertexId = "v" + (String(x) + ("_t" + (String(i) + ("_e" + (String(e.contents.id) + ("_s" + String(k)))))));
    vertexString = vertexString + (tab + (vertexId + "[style=filled, shape=circle, fillcolor=black; fixedsize=true; width=0.1; label=\"\"];\n"));
    if (e.contents.id <= x) {
      console.log("Trace!");
      inputWireString = inputWireString + (tab + (vertexId + (" -> e" + (String(x) + (":t" + (String(i) + ":e [arrowhead=none; arrowsize=0.5]\n"))))));
      outputWireString = outputWireString + (tab + (vertexId + (" -> e" + (String(e.contents.id) + (":s" + (String(k) + ":w [arrowhead=vee; arrowsize=0.5]\n"))))));
    } else {
      inputWireString = inputWireString + (tab + ("e" + (String(x) + (":t" + (String(i) + (":e -> " + (vertexId + ":w [arrowhead=none; arrowsize=0.5]\n")))))));
      outputWireString = outputWireString + (tab + (vertexId + (":e -> e" + (String(e.contents.id) + (":s" + (String(k) + ":w [arrowhead=vee; arrowsize=0.5]\n"))))));
    }
  }
  return /* array */[
          ranks,
          traceVertexString,
          vertexString,
          inputWireString,
          outputWireString,
          traceWireString
        ];
}

function generatePorts(n, out) {
  return "{" + (generatePorts$prime(0, n, out) + "}");
}

function generateGraphvizCode(net) {
  var derefedEdges = List.map((function (x) {
          return x.contents;
        }), net.edges);
  var allEdges = Pervasives.$at(/* :: */[
        net.inputs.contents,
        /* [] */0
      ], Pervasives.$at(derefedEdges, /* :: */[
            net.outputs.contents,
            /* [] */0
          ]));
  var graph = generateGraphvizCodeEdges(net.inputs, net.outputs, allEdges, "", "", "", "", "", "", "");
  var emptyGraph = List.length(net.edges) === 0;
  var match = !emptyGraph;
  var inputWires;
  if (match) {
    var match$1 = net.inputs.contents.targets.length === 0;
    inputWires = match$1 ? nl + makeTransitionToAllEdgesWithNoSources(net.inputs.contents.id, derefedEdges) : "";
  } else {
    inputWires = "";
  }
  var match$2 = !emptyGraph;
  var outputWires;
  if (match$2) {
    var match$3 = net.outputs.contents.sources.length === 0;
    outputWires = match$3 ? nl + makeTransitionToAllEdgesWithNoTargets(net.outputs.contents.id, derefedEdges) : "";
  } else {
    outputWires = "";
  }
  var match$4 = List.length(net.edges) === 0;
  var inputOutputWires = match$4 ? nl + (tab + ("e" + (String(net.inputs.contents.id) + ("->e" + (String(net.outputs.contents.id) + "[style=invis]\n"))))) : "";
  var finalGraph = "digraph{" + (nl + (nl + (graphOptions + (graph + (inputWires + (outputWires + (inputOutputWires + "\n}")))))));
  console.log(finalGraph);
  return finalGraph;
}

function generateOutputTransitions(outid, edges) {
  if (edges) {
    return "e" + (String(edges[0].id) + (" -> e" + (String(outid) + "[style=invis]\n")));
  } else {
    return "";
  }
}

var zeroDot = generateGraphvizCode(Hypernets$CircuitVisualiser.zeroNet);

function generateFormalGraphvizEdge(i, s, t, l) {
  var ins = List.length(s);
  var outs = List.length(t);
  var inports = generatePorts(ins, false);
  var outports = generatePorts(outs, true);
  var match = inports === "{}";
  var instring = match ? "" : inports + " | ";
  var match$1 = outports === "{}";
  var outstring = match$1 ? "" : " | " + outports;
  return "e" + (String(i) + ("[shape=Mrecord; label=\"{" + (instring + (l + (outstring + "}\"]")))));
}

function generateFormalGraphvizCode(param) {
  var t = param.t;
  var s = param.s;
  var fu = param.fu;
  var e = param.e;
  var edgeString = "";
  var normalSources = s[1];
  var normalTargets = t[1];
  for(var i = 0 ,i_finish = e - 1 | 0; i <= i_finish; ++i){
    var newEdgeString = generateFormalGraphvizEdge(i, Caml_array.caml_array_get(normalSources, i), Caml_array.caml_array_get(normalTargets, i), Caml_array.caml_array_get(fu, i));
    edgeString = tab + (newEdgeString + (nl + edgeString));
  }
  var inputEdge = generateFormalGraphvizEdge(e, /* [] */0, t[0], Hypernets$CircuitVisualiser.alpha);
  var outputEdge = generateFormalGraphvizEdge(e + 1 | 0, s[0], /* [] */0, Hypernets$CircuitVisualiser.omega);
  edgeString = tab + (outputEdge + (nl + (edgeString + (tab + inputEdge))));
  console.log(edgeString);
  return edgeString;
}

var dot = "•";

var traceVertexOptions = "[shape=circle, fillcolor=black; fixedsize=true; width=0.05; label=\"\"]";

export {
  dot ,
  arrow ,
  tab ,
  nl ,
  graphOptions ,
  vertexOptions ,
  outputWireOptions ,
  inputWireOptions ,
  invisibleWireOptions ,
  traceVertexOptions ,
  formalInputVertexOptions ,
  formalOutputVertexOptions ,
  getTraceText ,
  makeTransitionToAllEdgesWithNoSources ,
  makeTransitionToAllEdgesWithNoTargets ,
  generateGraphvizCode ,
  generateGraphvizCodeEdges ,
  generateGraphvizCodeEdge ,
  generatePorts ,
  generatePorts$prime ,
  generateTransitions ,
  generateOutputTransitions ,
  zeroDot ,
  generateFormalGraphvizEdge ,
  generateFormalGraphvizCode ,
  
}
/* zeroDot Not a pure module */
