// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as Block from "../../../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../../../node_modules/bs-platform/lib/es6/curry.js";
import * as $$String from "../../../node_modules/bs-platform/lib/es6/string.js";
import * as Caml_obj from "../../../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Caml_array from "../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Pervasives from "../../../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Caml_format from "../../../node_modules/bs-platform/lib/es6/caml_format.js";
import * as Caml_option from "../../../node_modules/bs-platform/lib/es6/caml_option.js";
import * as Caml_string from "../../../node_modules/bs-platform/lib/es6/caml_string.js";
import * as Caml_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_exceptions.js";
import * as Caml_builtin_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as Helpers$CircuitVisualiser from "./Helpers.bs.js";
import * as Circuits$CircuitVisualiser from "./Circuits.bs.js";

var ParseError = Caml_exceptions.create("Parser-CircuitVisualiser.ParseError");

function parseError(i, message) {
  throw [
        ParseError,
        "parse error, char " + (String(i) + (": " + message))
      ];
}

function stringToChars(s) {
  return List.map((function (i) {
                return Caml_string.get(s, i);
              }), Helpers$CircuitVisualiser.range(s.length - 1 | 0));
}

var openingBracketsRegEx = (/(\(|\[])/);

var closingBracketsRegEx = (/(\)|\])(\^[0-9]+)?/);

var roundBracketsClosingRegEx = (/(\))(\^[0-9]+)?/);

var squareBracketsClosingRegEx = (/(\])(\^[0-9]+)?/);

function match_(regex, string) {
  return Caml_option.null_to_opt(string.match(regex));
}

function makeRegExChecks(_i, _checks, token) {
  while(true) {
    var checks = _checks;
    var i = _i;
    if (checks) {
      var match = token.match(checks[0]);
      if (match !== null) {
        return /* tuple */[
                i,
                match
              ];
      } else {
        _checks = checks[1];
        _i = i + 1 | 0;
        continue ;
      }
    } else {
      return /* tuple */[
              -1,
              /* array */[]
            ];
    }
  };
}

function checkForMatches(token) {
  return makeRegExChecks(0, Circuits$CircuitVisualiser.constructRegExes, token);
}

function lengthOfTokens(tokens) {
  if (tokens) {
    return tokens[0].length + lengthOfTokens(tokens[1]) | 0;
  } else {
    return 0;
  }
}

function tokenise$prime(_chars, _current) {
  while(true) {
    var current = _current;
    var chars = _chars;
    if (chars) {
      var x = chars[0];
      if (x >= 47) {
        switch (x) {
          case 91 :
              var xs = chars[1];
              var match = List.length(current) === 0;
              if (match) {
                return /* :: */[
                        /* :: */[
                          /* "[" */91,
                          /* [] */0
                        ],
                        tokenise$prime(xs, /* [] */0)
                      ];
              } else {
                return /* :: */[
                        List.rev(current),
                        /* :: */[
                          /* :: */[
                            /* "[" */91,
                            /* [] */0
                          ],
                          tokenise$prime(xs, /* [] */0)
                        ]
                      ];
              }
          case 92 :
              break;
          case 93 :
              var xs$1 = chars[1];
              var match$1 = List.length(current) === 0;
              if (match$1) {
                return /* :: */[
                        /* :: */[
                          /* "]" */93,
                          /* [] */0
                        ],
                        tokenise$prime(xs$1, /* [] */0)
                      ];
              } else {
                return /* :: */[
                        List.rev(current),
                        /* :: */[
                          /* :: */[
                            /* "]" */93,
                            /* [] */0
                          ],
                          tokenise$prime(xs$1, /* [] */0)
                        ]
                      ];
              }
          case 94 :
              var xs$2 = chars[1];
              var match$2 = List.length(current) === 0;
              if (match$2) {
                _current = /* :: */[
                  /* "^" */94,
                  /* [] */0
                ];
                _chars = xs$2;
                continue ;
              } else {
                return /* :: */[
                        List.rev(current),
                        tokenise$prime(xs$2, /* :: */[
                              /* "^" */94,
                              /* [] */0
                            ])
                      ];
              }
          default:
            
        }
      } else if (x >= 32) {
        switch (x - 32 | 0) {
          case 0 :
              var xs$3 = chars[1];
              var match$3 = List.length(current) === 0;
              if (match$3) {
                _current = /* [] */0;
                _chars = xs$3;
                continue ;
              } else {
                return /* :: */[
                        List.rev(current),
                        tokenise$prime(xs$3, /* [] */0)
                      ];
              }
          case 8 :
              var xs$4 = chars[1];
              var match$4 = List.length(current) === 0;
              if (match$4) {
                return /* :: */[
                        /* :: */[
                          /* "(" */40,
                          /* [] */0
                        ],
                        tokenise$prime(xs$4, /* [] */0)
                      ];
              } else {
                return /* :: */[
                        List.rev(current),
                        /* :: */[
                          /* :: */[
                            /* "(" */40,
                            /* [] */0
                          ],
                          tokenise$prime(xs$4, /* [] */0)
                        ]
                      ];
              }
          case 9 :
              var xs$5 = chars[1];
              var match$5 = List.length(current) === 0;
              if (match$5) {
                return /* :: */[
                        /* :: */[
                          /* ")" */41,
                          /* [] */0
                        ],
                        tokenise$prime(xs$5, /* [] */0)
                      ];
              } else {
                return /* :: */[
                        List.rev(current),
                        /* :: */[
                          /* :: */[
                            /* ")" */41,
                            /* [] */0
                          ],
                          tokenise$prime(xs$5, /* [] */0)
                        ]
                      ];
              }
          case 1 :
          case 2 :
          case 3 :
          case 4 :
          case 5 :
          case 6 :
          case 7 :
          case 10 :
          case 11 :
          case 12 :
          case 13 :
              break;
          case 14 :
              var xs$6 = chars[1];
              var match$6 = List.length(current) === 0;
              if (match$6) {
                _current = /* :: */[
                  /* "." */46,
                  /* [] */0
                ];
                _chars = xs$6;
                continue ;
              } else {
                return /* :: */[
                        List.rev(/* :: */[
                              /* "." */46,
                              current
                            ]),
                        tokenise$prime(xs$6, /* [] */0)
                      ];
              }
          
        }
      }
      _current = /* :: */[
        x,
        current
      ];
      _chars = chars[1];
      continue ;
    } else {
      var match$7 = List.length(current) === 0;
      if (match$7) {
        return /* [] */0;
      } else {
        return /* :: */[
                List.rev(current),
                /* [] */0
              ];
      }
    }
  };
}

function tokenise(string) {
  return List.map((function (x) {
                return $$String.init(List.length(x), (function (i) {
                              return List.nth(x, i);
                            }));
              }), tokenise$prime(stringToChars(string), /* [] */0));
}

function scanForClosingBracket$prime(_xs, _i, _j, bracket, _brackstack) {
  while(true) {
    var brackstack = _brackstack;
    var j = _j;
    var i = _i;
    var xs = _xs;
    if (xs) {
      var x = xs[0];
      switch (x) {
        case "(" :
            _brackstack = /* :: */[
              ")",
              brackstack
            ];
            _j = j + 1 | 0;
            _i = i + 1 | 0;
            _xs = xs[1];
            continue ;
        case "[" :
            _brackstack = /* :: */[
              "]",
              brackstack
            ];
            _j = j + 1 | 0;
            _i = i + 1 | 0;
            _xs = xs[1];
            continue ;
        default:
          var xs$1 = xs[1];
          var match = x.match(closingBracketsRegEx);
          if (match !== null) {
            var a = Caml_array.caml_array_get(match, 1);
            if (List.length(brackstack) === 0) {
              return parseError(i, "unexpected " + (a + " encountered"));
            } else if (List.hd(brackstack) === a) {
              if (List.length(brackstack) === 1) {
                if (a === bracket) {
                  return j;
                } else {
                  return parseError(i, "bracket " + (bracket + " expected but not found"));
                }
              } else {
                _brackstack = List.tl(brackstack);
                _j = j + 1 | 0;
                _i = i + 1 | 0;
                _xs = xs$1;
                continue ;
              }
            } else {
              return parseError(i, "bracket " + (List.hd(brackstack) + (" expected but " + (a + " found"))));
            }
          } else {
            _j = j + 1 | 0;
            _i = i + 1 | 0;
            _xs = xs$1;
            continue ;
          }
      }
    } else {
      var match$1 = bracket === "";
      if (match$1) {
        return j;
      } else {
        return parseError(i, bracket + " expected");
      }
    }
  };
}

function scanForClosingBracket(xs, i, bracket) {
  return scanForClosingBracket$prime(xs, i, 0, bracket, /* :: */[
              bracket,
              /* [] */0
            ]);
}

function scanForNextComposition$prime(_xs, _i, _bracks) {
  while(true) {
    var bracks = _bracks;
    var i = _i;
    var xs = _xs;
    if (xs) {
      var x = xs[0];
      switch (x) {
        case "." :
            var match = bracks === 0;
            if (match) {
              return i;
            } else {
              _i = i + 1 | 0;
              _xs = xs[1];
              continue ;
            }
        case "(" :
        case "[" :
            break;
        default:
          var xs$1 = xs[1];
          var match$1 = x.match(closingBracketsRegEx);
          if (match$1 !== null) {
            _bracks = bracks - 1 | 0;
            _i = i + 1 | 0;
            _xs = xs$1;
            continue ;
          } else {
            _i = i + 1 | 0;
            _xs = xs$1;
            continue ;
          }
      }
      _bracks = bracks + 1 | 0;
      _i = i + 1 | 0;
      _xs = xs[1];
      continue ;
    } else {
      return i;
    }
  };
}

function scanForNextComposition(xs, i) {
  return scanForNextComposition$prime(xs, i, 0);
}

function functionLookup(func, funcs) {
  var item;
  try {
    item = List.find((function (x) {
            var match = x.c;
            if (match.tag === /* Function */5) {
              return match[0] === func;
            } else {
              return Pervasives.failwith("Unexpected non-function found in function library");
            }
          }), funcs);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    } else {
      throw exn;
    }
  }
  return item.c;
}

function macroLookup(macro, macros) {
  var item;
  try {
    item = List.find((function (x) {
            var match = x.c;
            if (match.tag === /* Macro */12) {
              return match[0] === macro;
            } else {
              return Pervasives.failwith("Unexpected non-macro found in function library");
            }
          }), macros);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    } else {
      throw exn;
    }
  }
  return item.c;
}

function linkLookup(link, links) {
  var item;
  try {
    item = List.find((function (x) {
            return Caml_obj.caml_equal(x[0][0], link);
          }), links);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      var exit = 0;
      var item$1;
      try {
        item$1 = List.find((function (x) {
                return Caml_obj.caml_equal(x[1][0], link);
              }), links);
        exit = 2;
      }
      catch (exn$1){
        if (exn$1 === Caml_builtin_exceptions.not_found) {
          return ;
        } else {
          throw exn$1;
        }
      }
      if (exit === 2) {
        return /* Input */Block.__(9, [item$1[1][1]]);
      }
      
    } else {
      throw exn;
    }
  }
  return /* Output */Block.__(10, [item[0][1]]);
}

function blah(a, b, c) {
  return c;
}

function parseBrackets(close, v, i, xs, stack, tensor, nextlink, defs, links) {
  var j = scanForClosingBracket(xs, i, close);
  var subtermTokens = Helpers$CircuitVisualiser.slice(xs, 0, j - 1 | 0);
  var parsedSubterm = parse$prime(v, i + 1 | 0, subtermTokens, /* [] */0, /* [] */0, false, nextlink, defs, links);
  var actualSubterm = parsedSubterm[0];
  var nextlink$1 = parsedSubterm[1];
  return parse$prime(v, (i + 1 | 0) + lengthOfTokens(subtermTokens) | 0, Helpers$CircuitVisualiser.trim(xs, j + 1 | 0), Pervasives.$at(stack, /* :: */[
                  actualSubterm,
                  /* [] */0
                ]), /* :: */[
              actualSubterm,
              /* [] */0
            ], tensor, nextlink$1, defs, links);
}

function parseTensor(v, i, xs, stack, tensor, nextlink, defs, links) {
  if (tensor) {
    return parse$prime(v, i + 2 | 0, xs, stack, /* [] */0, tensor, nextlink, defs, links);
  } else {
    var j = scanForNextComposition$prime(xs, 0, 0);
    var tensorTokens = Helpers$CircuitVisualiser.slice(xs, 0, j - 1 | 0);
    var parsedTensor = parse$prime(v, i + 2 | 0, tensorTokens, stack, /* [] */0, true, nextlink, defs, links);
    var actualTensor = parsedTensor[0];
    var nextlink$1 = parsedTensor[1];
    return parse$prime(v, (i + 2 | 0) + lengthOfTokens(tensorTokens) | 0, Helpers$CircuitVisualiser.trim(xs, j), Pervasives.$at(Helpers$CircuitVisualiser.drop(stack, 1), /* :: */[
                    actualTensor,
                    /* [] */0
                  ]), /* [] */0, false, nextlink$1, defs, links);
  }
}

function parseExponential(m, v, i, xs, stack, lastterm, tensor, nextlink, defs, links) {
  var n = Caml_format.caml_int_of_string(Caml_array.caml_array_get(m, 1));
  if (List.length(lastterm) !== 1) {
    return parseError(i, "exponential used without a valid term");
  } else {
    var newstack = processExponential(v, links, n, List.hd(lastterm), tensor);
    return parse$prime(v, (i + Caml_array.caml_array_get(m, 0).length | 0) + 1 | 0, xs, Pervasives.$at(Helpers$CircuitVisualiser.drop(stack, 1), newstack), lastterm, tensor, nextlink, defs, links);
  }
}

function parseTrace(m, v, i, xs, stack, tensor, nextlink, defs, links) {
  var x = Caml_format.caml_int_of_string(Caml_array.caml_array_get(m, 1));
  if (List.length(xs) === 0 || List.hd(xs) !== "(") {
    return parseError(i, "trace expected, no expression found");
  } else {
    var j = scanForClosingBracket(List.tl(xs), (i + 2 | 0) + Caml_array.caml_array_get(m, 0).length | 0, ")");
    var traceTokens = Helpers$CircuitVisualiser.slice(xs, 1, j);
    var parsedTrace = parse$prime(v, ((i + 1 | 0) + 1 | 0) + Caml_array.caml_array_get(m, 0).length | 0, traceTokens, /* [] */0, /* [] */0, false, nextlink, defs, links);
    var nextlink$1 = parsedTrace[1];
    var actualTrace = Circuits$CircuitVisualiser.trace(x, parsedTrace[0]);
    return parse$prime(v, ((((i + 1 | 0) + 1 | 0) + Caml_array.caml_array_get(m, 0).length | 0) + lengthOfTokens(traceTokens) | 0) + 1 | 0, Helpers$CircuitVisualiser.trim(xs, j + 2 | 0), Pervasives.$at(stack, /* :: */[
                    actualTrace,
                    /* [] */0
                  ]), /* :: */[
                actualTrace,
                /* [] */0
              ], tensor, nextlink$1, defs, links);
  }
}

function parseLink(m, v, i, xs, stack, tensor, nextlink, defs, links) {
  var oup = Caml_array.caml_array_get(m, 1);
  var inp = Caml_array.caml_array_get(m, 2);
  var inx = nextlink + 1 | 0;
  var newLinks_000 = /* tuple */[
    /* tuple */[
      oup,
      nextlink
    ],
    /* tuple */[
      inp,
      inx
    ]
  ];
  var newLinks = /* :: */[
    newLinks_000,
    links
  ];
  var nextlink$1 = nextlink + 2 | 0;
  var j = scanForClosingBracket(List.tl(xs), i + 4 | 0, "");
  var parsedScope = parse$prime(v, i + 6 | 0, Helpers$CircuitVisualiser.slice(xs, 0, j), /* [] */0, /* [] */0, false, nextlink$1, defs, newLinks);
  var actualScope = parsedScope[0];
  var nextlink$2 = parsedScope[1];
  var finalLink = Circuits$CircuitVisualiser.link(v, nextlink, inx, actualScope, links);
  return parse$prime(v, i + 1 | 0, Helpers$CircuitVisualiser.trim(xs, j + 1 | 0), Pervasives.$at(stack, /* :: */[
                  finalLink,
                  /* [] */0
                ]), /* :: */[
              finalLink,
              /* [] */0
            ], tensor, nextlink$2, defs, links);
}

function parseIteration(m, v, i, xs, stack, tensor, nextlink, defs, links) {
  if (List.length(xs) === 0 || List.hd(xs) !== "(") {
    return parseError(i, "iteration expected, no expression found");
  } else {
    var j = scanForClosingBracket(List.tl(xs), i + 6 | 0, ")");
    var iterationTokens = Helpers$CircuitVisualiser.slice(xs, 1, j);
    var parsedIteration = parse$prime(v, ((i + 1 | 0) + 1 | 0) + Caml_array.caml_array_get(m, 0).length | 0, iterationTokens, /* [] */0, /* [] */0, false, nextlink, defs, links);
    var nextlink$1 = parsedIteration[1];
    var actualIteration = Circuits$CircuitVisualiser.iter(parsedIteration[0]);
    return parse$prime(v, ((((i + 1 | 0) + 1 | 0) + Caml_array.caml_array_get(m, 0).length | 0) + lengthOfTokens(iterationTokens) | 0) + 1 | 0, Helpers$CircuitVisualiser.trim(xs, j + 2 | 0), Pervasives.$at(stack, /* :: */[
                    actualIteration,
                    /* [] */0
                  ]), /* :: */[
                actualIteration,
                /* [] */0
              ], tensor, nextlink$1, defs, links);
  }
}

function parse$prime(v, _i, _tokens, _stack, _lastterm, tensor, nextlink, defs, links) {
  while(true) {
    var lastterm = _lastterm;
    var stack = _stack;
    var tokens = _tokens;
    var i = _i;
    console.log("parsing " + Helpers$CircuitVisualiser.printStringList(tokens));
    if (tokens) {
      var xs = tokens[1];
      var x = tokens[0];
      switch (x) {
        case "(" :
            return parseBrackets(")", v, i, xs, stack, tensor, nextlink, defs, links);
        case ")" :
            return parseError(i, "unexpected ) encountered");
        case "*" :
            return parseTensor(v, i, xs, stack, tensor, nextlink, defs, links);
        case "." :
            return parseComposition(v, i, xs, stack, tensor, nextlink, defs, links);
        case "/\\" :
            _lastterm = /* [] */0;
            _tokens = /* :: */[
              "⋏",
              xs
            ];
            continue ;
        case "[" :
            return parseBrackets("]", v, i, xs, stack, tensor, nextlink, defs, links);
        case "\\/" :
            _lastterm = /* [] */0;
            _tokens = /* :: */[
              "⋎",
              xs
            ];
            continue ;
        case "]" :
            return parseError(i, "unexpected ] encountered");
        default:
          var matches = makeRegExChecks(0, Circuits$CircuitVisualiser.constructRegExes, x);
          var m = matches[1];
          var len = x.length;
          var match = matches[0];
          var exit = 0;
          switch (match) {
            case -1 :
                return parseTerm(x, v, i, xs, stack, tensor, nextlink, defs, links);
            case 0 :
                var x$1 = Caml_format.caml_int_of_string(Caml_array.caml_array_get(m, 1));
                var y = Caml_format.caml_int_of_string(Caml_array.caml_array_get(m, 2));
                _lastterm = /* :: */[
                  Circuits$CircuitVisualiser.swap(v, x$1, y),
                  /* [] */0
                ];
                _stack = Pervasives.$at(stack, /* :: */[
                      Circuits$CircuitVisualiser.swap(v, x$1, y),
                      /* [] */0
                    ]);
                _tokens = xs;
                _i = (i + 1 | 0) + len | 0;
                continue ;
            case 1 :
                var x$2 = Caml_format.caml_int_of_string(Caml_array.caml_array_get(m, 1));
                _lastterm = /* :: */[
                  Circuits$CircuitVisualiser.dfork(v, x$2),
                  /* [] */0
                ];
                _stack = Pervasives.$at(stack, /* :: */[
                      Circuits$CircuitVisualiser.dfork(v, x$2),
                      /* [] */0
                    ]);
                _tokens = xs;
                _i = (i + 1 | 0) + len | 0;
                continue ;
            case 2 :
                var x$3 = Caml_format.caml_int_of_string(Caml_array.caml_array_get(m, 1));
                _lastterm = /* :: */[
                  Circuits$CircuitVisualiser.djoin(v, x$3),
                  /* [] */0
                ];
                _stack = Pervasives.$at(stack, /* :: */[
                      Circuits$CircuitVisualiser.djoin(v, x$3),
                      /* [] */0
                    ]);
                _tokens = xs;
                _i = (i + 1 | 0) + len | 0;
                continue ;
            case 3 :
                var x$4 = Caml_format.caml_int_of_string(Caml_array.caml_array_get(m, 1));
                _lastterm = /* :: */[
                  Circuits$CircuitVisualiser.delay(v, x$4),
                  /* [] */0
                ];
                _stack = Pervasives.$at(stack, /* :: */[
                      Circuits$CircuitVisualiser.delay(v, x$4),
                      /* [] */0
                    ]);
                _tokens = xs;
                _i = (i + 1 | 0) + len | 0;
                continue ;
            case 4 :
                return parseTrace(m, v, i, xs, stack, tensor, nextlink, defs, links);
            case 5 :
            case 6 :
                exit = 1;
                break;
            case 7 :
                return parseExponential(m, v, i, xs, stack, lastterm, tensor, nextlink, defs, links);
            case 8 :
            case 9 :
                exit = 2;
                break;
            default:
              throw [
                    Caml_builtin_exceptions.match_failure,
                    /* tuple */[
                      "Parser.re",
                      186,
                      44
                    ]
                  ];
          }
          switch (exit) {
            case 1 :
                return parseIteration(m, v, i, xs, stack, tensor, nextlink, defs, links);
            case 2 :
                return parseLink(m, v, i, xs, stack, tensor, nextlink, defs, links);
            
          }
      }
    } else if (tensor) {
      return /* tuple */[
              Circuits$CircuitVisualiser.circ(v, /* Tensor */Block.__(3, [stack]), links),
              nextlink
            ];
    } else {
      var match$1 = List.length(stack) === 1;
      if (match$1) {
        return /* tuple */[
                List.hd(stack),
                nextlink
              ];
      } else {
        return parseError(i, "unexpected end of term");
      }
    }
  };
}

function parseComposition(v, i, xs, stack, tensor, nextlink, defs, links) {
  if (List.length(stack) === 0) {
    return parseError(i, "unexpected * encountered");
  } else {
    var parsedArgument = parse$prime(v, i + 2 | 0, xs, List.tl(stack), /* [] */0, tensor, nextlink, defs, links);
    var actualArgument = parsedArgument[0];
    var nextlink$1 = parsedArgument[1];
    return /* tuple */[
            Circuits$CircuitVisualiser.compose(List.hd(stack), actualArgument),
            nextlink$1
          ];
  }
}

function parseTerm(a, v, i, xs, stack, tensor, nextlink, defs, links) {
  if (!tensor && List.length(stack) > 0) {
    return parseError(i, "unexpected term encountered, did you forget a composition or tensor?");
  } else {
    var sym = Curry._1(v.parse, a);
    var match = sym[0];
    var subterm;
    if (match) {
      subterm = /* Value */Block.__(0, [sym[1]]);
    } else {
      var exit = 0;
      var item;
      try {
        item = Caml_format.caml_int_of_string(a);
        exit = 1;
      }
      catch (exn){
        var match$1 = functionLookup(a, defs[0]);
        if (match$1 !== undefined) {
          subterm = match$1;
        } else {
          var match$2 = macroLookup(a, defs[1]);
          if (match$2 !== undefined) {
            subterm = match$2;
          } else {
            var match$3 = linkLookup(a, links);
            subterm = match$3 !== undefined ? match$3 : parseError(i, "unable to parse " + a);
          }
        }
      }
      if (exit === 1) {
        subterm = /* Identity */Block.__(1, [item]);
      }
      
    }
    var subterm$1 = Circuits$CircuitVisualiser.circ(v, subterm, links);
    return parse$prime(v, (i + a.length | 0) + 1 | 0, xs, Pervasives.$at(stack, /* :: */[
                    subterm$1,
                    /* [] */0
                  ]), /* :: */[
                subterm$1,
                /* [] */0
              ], tensor, nextlink, defs, links);
  }
}

function processExponential(v, links, n, term, tensor) {
  if (n === 0 || n === 1) {
    return /* :: */[
            term,
            /* [] */0
          ];
  } else if (tensor) {
    return /* :: */[
            term,
            processExponential(v, links, n - 1 | 0, term, tensor)
          ];
  } else {
    return /* :: */[
            Circuits$CircuitVisualiser.circ(v, /* Tensor */Block.__(3, [/* :: */[
                      term,
                      processExponential(v, links, n - 1 | 0, term, true)
                    ]]), links),
            /* [] */0
          ];
  }
}

function parse(v, funcs, macros, tokens) {
  return parse$prime(v, 1, tokens, /* [] */0, /* [] */0, false, 0, /* tuple */[
              funcs,
              macros
            ], /* [] */0);
}

function parseFromString(v, funcs, macros, string) {
  var tokenisedString = tokenise(string);
  return parse(v, funcs, macros, tokenisedString)[0];
}

export {
  ParseError ,
  parseError ,
  stringToChars ,
  openingBracketsRegEx ,
  closingBracketsRegEx ,
  roundBracketsClosingRegEx ,
  squareBracketsClosingRegEx ,
  match_ ,
  makeRegExChecks ,
  checkForMatches ,
  lengthOfTokens ,
  tokenise ,
  tokenise$prime ,
  scanForClosingBracket ,
  scanForClosingBracket$prime ,
  scanForNextComposition ,
  scanForNextComposition$prime ,
  functionLookup ,
  macroLookup ,
  linkLookup ,
  blah ,
  parse ,
  parse$prime ,
  parseBrackets ,
  parseComposition ,
  parseTensor ,
  parseTrace ,
  parseIteration ,
  parseTerm ,
  parseExponential ,
  processExponential ,
  parseLink ,
  parseFromString ,
  
}
/* openingBracketsRegEx Not a pure module */
