// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as $$Array from "../../../node_modules/bs-platform/lib/es6/array.js";
import * as Curry from "../../../node_modules/bs-platform/lib/es6/curry.js";
import * as $$String from "../../../node_modules/bs-platform/lib/es6/string.js";
import * as Caml_obj from "../../../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Caml_array from "../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Pervasives from "../../../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Helpers$CircuitVisualiser from "./Helpers.bs.js";
import * as Hypernets$CircuitVisualiser from "./Hypernets.bs.js";

function printEdgePlusTwo(ept) {
  if (typeof ept === "number") {
    if (ept !== 0) {
      return "Output";
    } else {
      return "Input";
    }
  } else {
    return String(ept[0]);
  }
}

function generateFin$prime(x, _n, _i, _acc) {
  while(true) {
    var acc = _acc;
    var i = _i;
    var n = _n;
    var match = n === 0;
    if (match) {
      return acc;
    } else {
      _acc = acc + (x + ("_{" + (String(i) + "},")));
      _i = i + 1 | 0;
      _n = n - 1 | 0;
      continue ;
    }
  };
}

function generateFin(x, n) {
  var strn = generateFin$prime(x, n, 0, "");
  var match = strn.length !== 0;
  if (match) {
    return "\\{" + ($$String.sub(strn, 0, strn.length - 1 | 0) + "\\}");
  } else {
    return strn;
  }
}

function vertexLatex(v) {
  return "v_{" + (String(v) + "}");
}

function edgeLatex(e) {
  return "e_{" + (String(e) + "}");
}

function edgePlusTwoLatex(e) {
  if (typeof e === "number") {
    if (e !== 0) {
      return "\\omega";
    } else {
      return "\\alpha";
    }
  } else {
    return "e_{" + (String(e[0]) + "}");
  }
}

function printFunctionLatex(func, x, prnt) {
  var string = "\\{";
  for(var i = 0 ,i_finish = func.length - 1 | 0; i <= i_finish; ++i){
    var img = Curry._1(prnt, Caml_array.caml_array_get(func, i));
    string = string + (x + ("_{" + (String(i) + ("} \\mapsto " + (img + ",")))));
  }
  var match = string.length === 2;
  if (match) {
    return "\\{\\}";
  } else {
    return $$String.sub(string, 0, string.length - 1 | 0) + "\\}";
  }
}

function printFunctionFromEdgesToListsLatex(func, bonus, front) {
  var string = "";
  var bonusString = bonus + ("\\mapsto [" + (Helpers$CircuitVisualiser.printListCommas(func[0], vertexLatex) + "],"));
  var func$1 = func[1];
  for(var i = 0 ,i_finish = func$1.length - 1 | 0; i <= i_finish; ++i){
    string = string + (edgeLatex(i) + ("\\mapsto [" + (Helpers$CircuitVisualiser.printListCommas(Caml_array.caml_array_get(func$1, i), vertexLatex) + "],")));
  }
  string = front ? bonusString + string : string + bonusString;
  var match = string.length === 2;
  if (match) {
    return "\\{\\}";
  } else {
    return "\\{" + ($$String.sub(string, 0, string.length - 1 | 0) + "\\}");
  }
}

function algebraicNetLatex(param) {
  var result = "V^I = V^O = " + (generateFin("v", param.v) + ("\\\\E = " + (generateFin("e", param.e) + ("\\\\i = " + (printFunctionLatex(param.i, "v", edgePlusTwoLatex) + ("\\\\o = " + (printFunctionLatex(param.o, "v", edgePlusTwoLatex) + ("\\\\\\kappa = " + (printFunctionLatex(param.k, "v", vertexLatex) + ("\\\\L = \\{" + (Helpers$CircuitVisualiser.printListCommas(param.ll, (function (x) {
                                return x;
                              })) + ("\\}\\\\l = " + (printFunctionLatex(param.fl, "e", (function (x) {
                                    return x;
                                  })) + ("\\\\s = " + (printFunctionFromEdgesToListsLatex(param.s, Hypernets$CircuitVisualiser.omegaLatex, false) + ("\\\\t = " + printFunctionFromEdgesToListsLatex(param.t, Hypernets$CircuitVisualiser.alphaLatex, true)))))))))))))))));
  console.log(result);
  return result;
}

function numberOfEdges(net) {
  return List.length(net.edges);
}

function replaceEdgeMap$prime(valueMap, _func, _acc) {
  while(true) {
    var acc = _acc;
    var func = _func;
    if (func) {
      _acc = /* :: */[
        List.assoc(func[0], valueMap),
        acc
      ];
      _func = func[1];
      continue ;
    } else {
      return List.rev(acc);
    }
  };
}

function replaceEdgeMap(valueMap, func) {
  return replaceEdgeMap$prime(valueMap, func, /* [] */0);
}

function replaceEdgeMapFst$prime(valueMap, _func, _acc) {
  while(true) {
    var acc = _acc;
    var func = _func;
    if (func) {
      var match = func[0];
      _acc = /* :: */[
        /* tuple */[
          List.assoc(match[0], valueMap),
          match[1]
        ],
        acc
      ];
      _func = func[1];
      continue ;
    } else {
      return List.rev(acc);
    }
  };
}

function replaceEdgeMapFst(valueMap, func) {
  return replaceEdgeMapFst$prime(valueMap, func, /* [] */0);
}

function replaceEdgeMapSnd$prime(valueMap, _func, _acc) {
  while(true) {
    var acc = _acc;
    var func = _func;
    if (func) {
      var match = func[0];
      _acc = /* :: */[
        /* tuple */[
          match[0],
          List.assoc(match[1], valueMap)
        ],
        acc
      ];
      _func = func[1];
      continue ;
    } else {
      return List.rev(acc);
    }
  };
}

function replaceEdgeMapSnd(valueMap, func) {
  return replaceEdgeMapSnd$prime(valueMap, func, /* [] */0);
}

function normaliseEdgeIds$prime(inid, outid, _n, _eds, _valueMap) {
  while(true) {
    var valueMap = _valueMap;
    var eds = _eds;
    var n = _n;
    if (eds) {
      var e = eds[0];
      var match = Caml_obj.caml_equal(e, inid);
      var match$1;
      if (match) {
        match$1 = /* tuple */[
          /* Input */0,
          n
        ];
      } else {
        var match$2 = Caml_obj.caml_equal(e, outid);
        match$1 = match$2 ? /* tuple */[
            /* Output */1,
            n
          ] : /* tuple */[
            /* Edge */[n],
            n + 1 | 0
          ];
      }
      _valueMap = /* :: */[
        /* tuple */[
          e,
          match$1[0]
        ],
        valueMap
      ];
      _eds = eds[1];
      _n = match$1[1];
      continue ;
    } else {
      return valueMap;
    }
  };
}

function normaliseEdgeIds(inid, outid, eds, is, os, fu, fl) {
  var valueMap = normaliseEdgeIds$prime(inid, outid, 0, eds, /* [] */0);
  return /* tuple */[
          replaceEdgeMap$prime(valueMap, eds, /* [] */0),
          replaceEdgeMapSnd$prime(valueMap, is, /* [] */0),
          replaceEdgeMapSnd$prime(valueMap, os, /* [] */0),
          replaceEdgeMapFst$prime(valueMap, fu, /* [] */0),
          replaceEdgeMapFst$prime(valueMap, fl, /* [] */0)
        ];
}

function generateInputsAndOutputs(i, o, edge) {
  var sources = edge.contents.sources;
  var targets = edge.contents.targets;
  var id = edge.contents.id;
  var is = /* [] */0;
  var os = /* [] */0;
  for(var j = 0 ,j_finish = sources.length - 1 | 0; j <= j_finish; ++j){
    var x = j + i | 0;
    os = /* :: */[
      /* tuple */[
        x,
        id
      ],
      os
    ];
  }
  for(var j$1 = 0 ,j_finish$1 = targets.length - 1 | 0; j$1 <= j_finish$1; ++j$1){
    var x$1 = j$1 + o | 0;
    is = /* :: */[
      /* tuple */[
        x$1,
        id
      ],
      is
    ];
  }
  return /* tuple */[
          List.rev(is),
          List.rev(os)
        ];
}

function generateConnections(edge, is, os) {
  var targets = edge.contents.targets;
  var id = edge.contents.id;
  var ks = /* [] */0;
  var ous = List.filter((function (param) {
            return param[1] === id;
          }))(is);
  for(var j = 0 ,j_finish = targets.length - 1 | 0; j <= j_finish; ++j){
    var v1 = List.nth(ous, j)[0];
    var match = Caml_array.caml_array_get(targets, j);
    var e = match[0];
    var ins = List.filter((function(e){
          return function (param) {
            return e.contents.id === param[1];
          }
          }(e)))(os);
    var v2 = List.nth(ins, match[1])[0];
    ks = /* :: */[
      /* tuple */[
        v1,
        v2
      ],
      ks
    ];
  }
  return List.rev(ks);
}

function generateAllConnections$prime(os, is, _es, _acc) {
  while(true) {
    var acc = _acc;
    var es = _es;
    if (es) {
      var ks = generateConnections(es[0], is, os);
      _acc = Pervasives.$at(acc, ks);
      _es = es[1];
      continue ;
    } else {
      return acc;
    }
  };
}

function generateAllConnections(os, is, es) {
  return generateAllConnections$prime(os, is, es, /* [] */0);
}

function generateSourcesAndTargets(eds, is, os) {
  var sources = List.map((function (x) {
          return List.filter((function (param) {
                          return Caml_obj.caml_equal(param[1], x);
                        }))(os);
        }), eds);
  var targets = List.map((function (x) {
          return List.filter((function (param) {
                          return Caml_obj.caml_equal(param[1], x);
                        }))(is);
        }), eds);
  var sourceSplit = Helpers$CircuitVisualiser.split(List.length(sources) - 1 | 0, sources);
  var targetSplit = Helpers$CircuitVisualiser.split(1, targets);
  var sources_000 = List.map((function (prim) {
          return prim[0];
        }), List.nth(sourceSplit[1], 0));
  var sources_001 = $$Array.of_list(List.map((function (xs) {
              return List.map((function (prim) {
                            return prim[0];
                          }), xs);
            }), Helpers$CircuitVisualiser.trim(sourceSplit[0], 1)));
  var sources$1 = /* tuple */[
    sources_000,
    sources_001
  ];
  var targets_000 = List.map((function (prim) {
          return prim[0];
        }), List.nth(targetSplit[0], 0));
  var targets_001 = $$Array.of_list(List.map((function (xs) {
              return List.map((function (prim) {
                            return prim[0];
                          }), xs);
            }), Helpers$CircuitVisualiser.drop(targetSplit[1], 1)));
  var targets$1 = /* tuple */[
    targets_000,
    targets_001
  ];
  return /* tuple */[
          sources$1,
          targets$1
        ];
}

function generateAlgebraicDefinition$prime$prime(_edges, _i, _o, _eds, _is, _os, _lu, _ll, _fu, _fl) {
  while(true) {
    var fl = _fl;
    var fu = _fu;
    var ll = _ll;
    var lu = _lu;
    var os = _os;
    var is = _is;
    var eds = _eds;
    var o = _o;
    var i = _i;
    var edges = _edges;
    if (edges) {
      var e = edges[0];
      var match = generateInputsAndOutputs(i, o, e);
      var match$1 = List.mem(e.contents.label, lu) || e.contents.label === Hypernets$CircuitVisualiser.alpha || e.contents.label === Hypernets$CircuitVisualiser.omega;
      var lu$prime = match$1 ? lu : /* :: */[
          e.contents.label,
          lu
        ];
      var match$2 = List.mem(e.contents.latex, ll) || e.contents.latex === Hypernets$CircuitVisualiser.alphaLatex || e.contents.latex === Hypernets$CircuitVisualiser.omegaLatex;
      var ll$prime = match$2 ? ll : /* :: */[
          e.contents.latex,
          ll
        ];
      var match$3 = e.contents.label === Hypernets$CircuitVisualiser.alpha || e.contents.label === Hypernets$CircuitVisualiser.omega;
      var fu$prime = match$3 ? fu : /* :: */[
          /* tuple */[
            e.contents.id,
            e.contents.label
          ],
          fu
        ];
      var match$4 = e.contents.latex === Hypernets$CircuitVisualiser.alphaLatex || e.contents.latex === Hypernets$CircuitVisualiser.omegaLatex;
      var fl$prime = match$4 ? fl : /* :: */[
          /* tuple */[
            e.contents.id,
            e.contents.latex
          ],
          fl
        ];
      _fl = fl$prime;
      _fu = fu$prime;
      _ll = ll$prime;
      _lu = lu$prime;
      _os = Pervasives.$at(os, match[1]);
      _is = Pervasives.$at(is, match[0]);
      _eds = /* :: */[
        e.contents.id,
        eds
      ];
      _o = o + e.contents.targets.length | 0;
      _i = i + e.contents.sources.length | 0;
      _edges = edges[1];
      continue ;
    } else {
      return /* tuple */[
              i,
              List.rev(eds),
              is,
              os,
              List.rev(lu),
              List.rev(ll),
              List.rev(fu),
              List.rev(fl)
            ];
    }
  };
}

function generateAlgebraicDefinition$prime(edges) {
  return generateAlgebraicDefinition$prime$prime(edges, 0, 0, /* [] */0, /* [] */0, /* [] */0, /* [] */0, /* [] */0, /* [] */0, /* [] */0);
}

function generateAlgebraicDefinition(net) {
  var allEdges = Pervasives.$at(/* :: */[
        net.inputs,
        /* [] */0
      ], Pervasives.$at(net.edges, /* :: */[
            net.outputs,
            /* [] */0
          ]));
  var match = generateAlgebraicDefinition$prime(allEdges);
  var os = match[3];
  var is = match[2];
  var ks = generateAllConnections(os, is, allEdges);
  var match$1 = normaliseEdgeIds(net.inputs.contents.id, net.outputs.contents.id, match[1], is, os, match[6], match[7]);
  var os$1 = match$1[2];
  var is$1 = match$1[1];
  var eds = match$1[0];
  var match$2 = generateSourcesAndTargets(eds, is$1, os$1);
  return {
          v: match[0],
          e: List.length(eds) - 2 | 0,
          i: $$Array.of_list(List.map((function (prim) {
                      return prim[1];
                    }), is$1)),
          o: $$Array.of_list(List.map((function (prim) {
                      return prim[1];
                    }), os$1)),
          k: $$Array.of_list(List.map((function (prim) {
                      return prim[1];
                    }), ks)),
          lu: match[4],
          ll: match[5],
          fu: $$Array.of_list(List.map((function (prim) {
                      return prim[1];
                    }), match$1[3])),
          fl: $$Array.of_list(List.map((function (prim) {
                      return prim[1];
                    }), match$1[4])),
          s: match$2[0],
          t: match$2[1]
        };
}

export {
  printEdgePlusTwo ,
  generateFin ,
  generateFin$prime ,
  vertexLatex ,
  edgeLatex ,
  edgePlusTwoLatex ,
  printFunctionLatex ,
  printFunctionFromEdgesToListsLatex ,
  algebraicNetLatex ,
  numberOfEdges ,
  replaceEdgeMap ,
  replaceEdgeMap$prime ,
  replaceEdgeMapFst ,
  replaceEdgeMapFst$prime ,
  replaceEdgeMapSnd ,
  replaceEdgeMapSnd$prime ,
  normaliseEdgeIds ,
  normaliseEdgeIds$prime ,
  generateInputsAndOutputs ,
  generateConnections ,
  generateAllConnections ,
  generateAllConnections$prime ,
  generateSourcesAndTargets ,
  generateAlgebraicDefinition ,
  generateAlgebraicDefinition$prime ,
  generateAlgebraicDefinition$prime$prime ,
  
}
/* Hypernets-CircuitVisualiser Not a pure module */
