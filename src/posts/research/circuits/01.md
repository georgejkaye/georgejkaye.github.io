---
layout: post
part: Part One
date: 2022-02-18
tagline: Digital circuits are ubiquitous in today's society. But what if we gave them the categorical treatment?
---

## Introduction

Digital circuit

In the business, reasoning with circuits is generally performed by translating them into some sort of automata (such as a Mealy or a Moore machine) and then *simulating* them for some given inputs.

To do this, we must look o
Circuits are constructed from the basic building blocks of *logic gates*.
We can then compose these together in a variety of ways to 

If these seem familiar then 
## Syntax

With the various signals at play under our belt, we can get to the fun stuff.
To construct circuits formally, we can model them as morphisms (or *terms*) in a *symmetric monoidal category*.
Rather than using the traditional method of writing terms as one-dimensional text strings, we will use the graphical syntax of *string diagrams* \[JS81, Sel10\].
Not only does this make things a lot clearer, it has a practical benefit in that it can eliminate a lot of structural bureaucracy, such as having to deal with associativity all the time.

Constructing circuits is simply a matter of getting a load of gates and bashing them together.
The categorical parallel of this is a *freely generated symmetric monoidal category*.
In this setting, we have a set of *generators*: these are our basic building blocks.

Clearly, our logic gates make up one class of generators in digital circuits.
Another class we must include are the *values* that signals can take in our circuits.
In the categorical model these are generators $0 \to 1$.
An obvious choice is *true* ($\mathsf{t}$) and *false* ($\mathsf{f}$).
We also augment this with two 'special' values: a disconnected wire ($\bot$) and a short circuit ($\top$), and they have special drawings as shown below.
The reasoning behind these two values and their special status will become apparent later!

{% figure %}
    {% tikz "circuits/components/gates/and" %}
    {% tikz "circuits/components/gates/or" %}
    {% tikz "circuits/components/gates/not" %}
    {% tikz "circuits/components/values/true" %}
    {% tikz "circuits/components/values/false" %}
    {% tikz "strings/monoids/discard-r" %}
    {% tikz "strings/monoids/discard-r-white" %}
{% endfigure %}

So our circuits are not just a load of linear circuits plonked in a line consecutively, we also require some common *structural* generators.
We can *fork* wires, *stub* redundant ones, or *join* them together.
Finally we can extend wires with an *identity*, or swap them over with a *symmetry*.

{% figure %}
    {% tikz "strings/monoids/copy-lr" %}
    {% tikz "strings/monoids/discard-l" %}
    {% tikz "strings/monoids/copy-rl" %}
    {% tikz "strings/category/identity" %}
    {% tikz "strings/symmetric/symmetry" %}
{% endfigure %}


On their own these generators aren't very interesting, but we can put them together horizontally (*composition*) or vertically (*tensor*) to create bigger circuits.
We write {% tikz "strings/category/f.caps" %} with capital letters to represent composite morphisms constructed in this way.

{% figure %}
    {% tikz "strings/category/composition.caps" %}
    {% tikz "strings/monoidal/tensor.caps" %}
{% endfigure %}

When drawing boxes with multiple wires, we will often compress them into a single wires like {% tikz "circuits/components/fcirc" %}, but the actual number should be clear from context.

### Delay and feedback

By composing the generators in the previous section together in various ways you can create all sorts of circuits.
But there is one crucial property they all share: these are *combinational circuits*, circuits that act as functions on their inputs, always producing the same outputs given the same inputs.


What makes circuits interesting is the inclusion of *delay* and *feedback*.
These are what are known as *sequential circuits*.

Representing delay is easy: we can add an additional generator:

{% figure %}
    {% tikz "circuits/components/delay" %}
{% endfigure %}

For feedback we need to add another operation to our framework: a *trace operator*.
This connects some of the outputs of a circuit back to its inputs.

{% figure %}
    {% tikz "strings/traced/trace-lhs-rhs" %}
{% endfigure %}

This turns our category of digital circuits into a *symmetric traced monoidal category*, or STMC.
There are four axioms of STMCs, all of which are clear from the string diagram notation:

{% figure %}
    {% tikz "strings/traced/sliding" %}
    {% tikz "strings/traced/superposing" %}
{% endfigure %}

{% figure %}
    {% tikz "strings/traced/naturality" %}
    {% tikz "strings/traced/yanking" %}
{% endfigure %}



{% remark %}
    Another common categorical framework for modelling circuit-like structures (such as [electrical circuits](https://arxiv.org/abs/2106.07763) or [signal flow graphs](https://www.ioc.ee/~pawel/papers/popl15.pdf)) is that of a *compact closed category*.
    These settings are equipped with 'cups and caps' that can be used to 'bend' wires.
    {% figure %}
        {% tikz "strings/compact-closed/cup" %}
        {% tikz "strings/compact-closed/cap" %}
    {% endfigure %}

    However, this is not suitable for the setting of digital circuits as wires effectively become *bidirectional*: using the cup and the cap one can connect outputs to outputs and inputs to inputs.
    Clearly this is not a good model for digital circuits!

    Nevertheless, the two settings are intricately linked.
    Every compact closed category is equipped with a *canonical trace* by building one from cups and caps, and from a traced category one can use the *Int-construction* to obtain a compact closed category.
    You can find out more in this [nlab article](https://ncatlab.org/nlab/show/traced+monoidal+category#RelationToCompactClosedCategories).

{% endremark %}

## Semantics

While we can now make some very pretty string diagrams, our work so far is otherwise completely useless: there is no *computational content* to our circuits.
To add *semantics*, first we must interpret our gates and values in some domain.

As we have seen before, we have more than just the classic true and false values.
We also have $\bot$, which can be thought of as carrying no signal at all, and $\top$, which is like 'both signals at once'.
These two additional values were actually proposed many decades ago by [Nuel Belnap](https://en.wikipedia.org/wiki/Nuel_Belnap) in his [four-valued logic](https://en.wikipedia.org/wiki/Four-valued_logic#Belnap).
In his system, the four values form two lattices and operations are monotone functions.
Recall that a *lattice* is a poset in which every two elements have a unique supremum (or *join*) and minimum (or *meet*).
The two lattice are then as shown below:

{% figure %}
{% tikz "circuits/lattices" %}
{% endfigure %}

The first lattice (**A4**, $\sqsubseteq$) is the *approximation lattice*, corresponding to how much 'information' is contained in each signal.
As we have establish, the bottom element $\bot$ represents a *lack* of data, and the top element $\top$ represents a *glut* of data.
The $\mathsf{t}$ and $\mathsf{f}$ values sit in the middle, since they carry one piece of information.
The join in this lattice $\sqcup$ determines the result of joining two wires together.
For example, $\mathsf{t} \sqcup \mathsf{f}$ would result in $\top$: both pieces of information at once.

The second lattice (**L4**, $\leq$) is the *logical lattice*, which deals with how much 'truth' there is in a signal.
The lattice determines how we can derive logical operations.
For example, AND is the join $\wedge$ in **L4** and OR is the meet $\vee$.
The complete truth tables are drawn below:

$\wedge$ | $\bot$ | $\mathsf{t}$ | $\mathsf{f}$ | $\top$ | | $\vee$ |  $\bot$ | $\mathsf{t}$ | $\mathsf{f}$ | $\top$ | | $\neg$ | |
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
$\bot$ | $\bot$ | $\bot$ | $\mathsf{f}$ | $\mathsf{f}$ | | $\bot$ | $\bot$ | $\mathsf{t}$ | $\bot$ | $\mathsf{t}$ | | $\bot$ | $\bot$
$\mathsf{t}$ | $\bot$ | $\mathsf{t}$ | $\mathsf{f}$ | $\top$ | | $\mathsf{t}$ |  $\mathsf{t}$ | $\mathsf{t}$ | $\mathsf{t}$ | $\mathsf{t}$ | | $\mathsf{t}$ | $\mathsf{f}$ |
$\mathsf{f}$ | $\mathsf{f}$ | $\mathsf{f}$ | $\mathsf{f}$ | $\mathsf{f}$ | | $\mathsf{f}$ | $\bot$ | $\mathsf{t}$ | $\mathsf{f}$ | $\top$ | | $\mathsf{f}$ | $\mathsf{t}$
$\top$ | $\mathsf{f}$ | $\top$ | $\mathsf{f}$ | $\top$ | | $\top$ | $\mathsf{t}$ | $\mathsf{t}$ | $\top$ | $\top$ | | $\top$ | $\top$

Note that all the usual logical identities ($\mathsf{f} \wedge x = \mathsf{f}$, $\mathsf{t} \wedge x = x$ etc) still hold in the four-value case.


When considering semant
The semantics of circuits is that of *monotone stream functions*: 

## Combinational feedback


## References

* \[GJ16\] 
* \[GJL17\]