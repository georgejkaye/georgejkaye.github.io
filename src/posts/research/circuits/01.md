---
layout: post
part: Part One
date: 2022-02-18
tagline: Digital circuits are ubiquitous in today's society. But what if we gave them the categorical treatment?
---

## Introduction

Digital circuit

In the business, reasoning with circuits is generally performed by translating them into some sort of automata (such as a Mealy or a Moore machine) and then *simulating* them for some given inputs.

To do this, we must look o
Circuits are constructed from the basic building blocks of *logic gates*.
We can then compose these together in a variety of ways to 

If these seem familiar then 

## Syntax

To construct circuits formally, we can model them as morphisms (or *terms*) in a *freely generated symmetric monoidal category*.
In this setting, we have a set of *generators* with which form the basic building blocks of our system.
More complex terms can be generated by composing these generators together.

Traditionally, these terms would be written as one-dimensional text strings, combining generator symbols with operations such as $⨟$ and $\otimes$.
However, this quickly grows intractable for anything more than toy examples, and much of the intuition is lost. 
For example, it is almost impossible to work out what is going on in here:
$$(f \,⨟\, k \otimes \mathsf{id}_{C}) \otimes h \,⨟\, \mathsf{id}_B \otimes (\gamma \,⨟\, g)$$

without really squinting a bit.
It is also *inefficient*, as one has to navigate bureaucracy such as associativity during proofs.

Instead, we can use *string diagrams* \[JS81,Sel10\] to write our categorical terms *graphically*.

In a general Morphisms $X \to Y$ in a monoidal category can be thought of as processes that take as input something of a type $X$ and output something of type $Y$.

However, we need not be so general.
When considering circuits, the input and output types simply correspond to the number of open wires, so we can let the types $X,Y,Z,\cdots$ be natural numbers.
This means that we are working in a *products and permutations category*, or *prop* for short.

A circuit with $m$ inputs and $n$ outputs can be thought of as a morphism $f : m \to n$ 


The objects in thi

To construct digital circuits, we use a *freely generated* monoidal category.
These settings are equipped with a set of *generators* that we can then smash together in sequence and parallel.
Therefore before we can dive into constructing a circuit we must specify these generators: the basic building blocks of the circuit.

{% defn "Circuit signature" %}
    A circuit signature is a tuple $\Sigma = (\mathcal{V},\mathcal{G})$ where $\mathcal{V}$ is a finite set of *values* and $\mathcal{G}$ is a finite set of *gates* with associated arities.
{% enddefn %}

{% ex %}
    Throughout this series we will $\Sigma_\star = (V, G)$ where $V = \{\mathsf{t},\mathsf{f}\}$ and $G = \{(\text{AND},2),(\text{OR},2),(\text{NOT},2)\}$.
{% endex %}


We can think of a morphism $f : A \to B$ in a monoidal category, a morphism 

### Combinational circuits

Traditionally, terms in monoidal categories are written as one-dimensional strings, by combining the generators with symbols such as $⨟$ and $\otimes$ to denote sequential and parallel composition.
This can get unwieldy fast when dealing with anything more complex than a few generators.
From a practical viewpoint, it is also quite an *inefficient* representation, as lots of structural axioms get in the way.

Fortunately, the language of *string diagrams* [JS91,Sel10] can save the day.
In this case, a morphism $F : m \to n$ is written as a box ![](/tikz/components/fcirc.tikz.svg) with $m$ wires on its left and $n$ wires on its right.

Recently, 


Rather than reasoning purely with one-dimensional categorical 

First we will look at *combinational* circuits.
These are circuits that act exactly as functions do: one gives them some inputs and they always return the same output, with no concept of delay or feedback.
Common examples are adders, which are everywhere in circuits!



## Semantics



## Combinational feedback


## References

* \[GJ16\] 
* \[GJL17\]